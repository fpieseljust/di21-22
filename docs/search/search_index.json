{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts!! Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 21/22. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Home"},{"location":"#benvinguts","text":"Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 21/22. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Benvinguts!!"},{"location":"about/","text":"Desenvolupament d'interf\u00e9cies RD: 450/2010 Curr\u00edculum CV: Ordre 58/2012 IES Jaume II \"El Just\" - Tavernes de la Valldigna Curs 2021-2022 Professor: Ferran Cunyat","title":"About"},{"location":"about/#desenvolupament-dinterfecies","text":"RD: 450/2010 Curr\u00edculum CV: Ordre 58/2012","title":"Desenvolupament d'interf\u00e9cies"},{"location":"about/#ies-jaume-ii-el-just-tavernes-de-la-valldigna","text":"","title":"IES Jaume II \"El Just\" - Tavernes de la Valldigna"},{"location":"about/#curs-2021-2022","text":"Professor: Ferran Cunyat","title":"Curs 2021-2022"},{"location":"unitats/pyside6/pyside6-dialogs-alerts/","text":"Dialegs i alertes Dialegs Els di\u00e0legs s\u00f3n components de la GUI \u00fatils que ens permeten comunicar-nos amb l'usuari (d'aqu\u00ed el seu nom). S'utilitzen habitualment per obrir/gurdar fitxers, configuraci\u00f3, prefer\u00e8ncies o per a funcions que no encaixen a la interf\u00edcie principal de l'aplicaci\u00f3. S\u00f3n xicotetes finestres modals (o de bloqueig) que se situen davant de l'aplicaci\u00f3 principal fins que es descarten. Qt ofereix una s\u00e8rie de di\u00e0legs \"especials\" per als casos d'\u00fas m\u00e9s habituals, cosa que ens permet oferir una experi\u00e8ncia d'usuari nativa. A Qt els quadres de di\u00e0leg s\u00f3n gestionats per la classe QDialog. Per crear un quadre de di\u00e0leg nou, simplement creem un nou objecte de tipus QDialog passant un altre widget, per exemple QMainWindow, com a pare. Creem el nostre propi QDialog. Comen\u00e7arem amb una aplicaci\u00f3 simple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): print ( \"click\" , s ) dlg = QDialog ( self ) dlg . setWindowTitle ( \"HELLO!\" ) dlg . exec () app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () A la ranura button_clicked creem la inst\u00e0ncia de di\u00e0leg, passant la nostra inst\u00e0ncia QMainWindow com a pare. Aix\u00f2 far\u00e0 que el di\u00e0leg siga una finestra modal de QMainWindow. Aix\u00f2 significa que el di\u00e0leg bloquejar\u00e0 completament la interacci\u00f3 amb la finestra principal. Una vegada hem creat el di\u00e0leg, l'iniciem amb .exec() - igual que vam fer amb QApplication per crear el bucle d'esdeveniments principal de la nostra aplicaci\u00f3. Aix\u00f2 no \u00e9s una coincid\u00e8ncia: quan executeu el QDialog es crea un bucle d'esdeveniments completament nou, espec\u00edfic per al di\u00e0leg. El QDialog bloqueja completament l'execuci\u00f3 de l'aplicaci\u00f3. No inicieu cap di\u00e0leg i espereu que passe res m\u00e9s en qualsevol altre lloc de la vostra aplicaci\u00f3. M\u00e9s endavant veurem com pots utilitzar fils i processos per esquivar aquest problema. Afegim els botons D'acord i Cancel\u00b7la per permetre a l'usuari acceptar o rebutjar el modal. Per personalitzar el QDialog podem heredar d'ell. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from PySide6.QtWidgets import QDialog , QDialogButtonBox , QVBoxLayout , QLabel class CustomDialog ( QDialog ): def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setWindowTitle ( \"HELLO!\" ) QBtn = QDialogButtonBox . Ok | QDialogButtonBox . Cancel self . buttonBox = QDialogButtonBox ( QBtn ) self . buttonBox . accepted . connect ( self . accept ) self . buttonBox . rejected . connect ( self . reject ) self . layout = QVBoxLayout () message = QLabel ( \"Something happened, is that OK?\" ) self . layout . addWidget ( message ) self . layout . addWidget ( self . buttonBox ) self . setLayout ( self . layout ) Podeu optar per utilitzar un QButton est\u00e0ndard en un disseny, per\u00f2 l'enfocament descrit ac\u00ed garanteix que el vostre di\u00e0leg respecta els est\u00e0ndards de l'escriptori amfitri\u00f3 (d'acord a l'esquerra o a la dreta, per exemple). Jugar amb aquests comportaments pot ser incre\u00efblement molest per als usuaris, aix\u00ed que \u00e9s recomanable consultar la documentaci\u00f3 i seguir les guies d'estil de cada plataforma. El primer pas per crear un quadre de botons de di\u00e0leg \u00e9s definir els botons que es volen mostrar, utilitzant els atributs de QDialogButtonBox. La llista completa de botons disponibles est\u00e0 a continuaci\u00f3: QDialogButtonBox.Ok QDialogButtonBox.Open QDialogButtonBox.Save QDialogButtonBox.Cancel QDialogButtonBox.Close QDialogButtonBox.Discard QDialogButtonBox.Apply QDialogButtonBox.Reset QDialogButtonBox.RestoreDefaults QDialogButtonBox.Help QDialogButtonBox.SaveAll QDialogButtonBox.Yes QDialogButtonBox.YesToAll QDialogButtonBox.No QDialogButtonBox.Abort QDialogButtonBox.Retry QDialogButtonBox.Ignore QDialogButtonBox.NoButton Aquests haurien de ser suficients per crear qualsevol quadre de di\u00e0leg. Podeu construir una l\u00ednia de diversos botons posant-los junts amb el s\u00edmbol | . Qt ho gestionar\u00e0, segons els est\u00e0ndards de la plataforma. Per exemple, per mostrar un bot\u00f3 OK i Cancel\u00b7la hem utilitzat: Python 1 buttons = QDialogButtonBox . Ok | QDialogButtonBox . Cancel La variable buttons ara cont\u00e9 un valor enter que representa aquests dos botons. A continuaci\u00f3, hem de crear la inst\u00e0ncia QDialogButtonBox i la passem com a primer par\u00e0metre. Perqu\u00e8 els botons tinguen algun efecte, heu de connectar els senyals QDialogButtonBox correctes a les ranures del di\u00e0leg. En el nostre cas, hem connectat els senyals accepted i rejected del QDialogButtonBox als controladors de accept i reject de la nostra subclasse de QDialog. Finalment, per fer que el QDialogButtonBox aparega al nostre quadre de di\u00e0leg hem d'afegir-lo al di\u00e0leg. Finalment, iniciem el CustomDialog a la nostra ranura MainWindow.button_clicked . Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QPushButton import customdialog1 class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): # print(\"click\", s) dlg = customdialog1 . CustomDialog ( self ) if dlg . exec (): print ( \"Success!\" ) else : print ( \"Cancel!\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Di\u00e0legs amb missatges simples (QMessageBox) Hi ha molts di\u00e0legs que segueixen el patr\u00f3 senzill que acabem de veure: un missatge amb botons amb els quals podeu acceptar o cancel\u00b7lar el di\u00e0leg. Tot i que podeu construir aquests di\u00e0legs vosaltres mateixos, Qt tamb\u00e9 proporciona una classe de di\u00e0leg de missatge integrada anomenada QMessageBox. Aix\u00f2 es pot utilitzar per crear di\u00e0legs d'informaci\u00f3, avisos o preguntes. L'exemple seg\u00fcent crea un QMessageBox senzill i el mostra. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QMessageBox , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): dlg = QMessageBox ( self ) dlg . setWindowTitle ( \"I have a question!\" ) dlg . setText ( \"This is a simple dialog\" ) button = dlg . exec_ () if button == QMessageBox . Ok : print ( \"OK!\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () Igual que amb el quadre de botons de di\u00e0leg que ja hem vist, els botons que es mostren en un QMessageBox tamb\u00e9 es configuren amb un conjunt de constants que es poden combinar amb | (l'operador OR binari) per mostrar diversos botons. A continuaci\u00f3 es mostra la llista completa dels tipus de botons disponibles: QMessageBox.Ok QMessageBox.Open QMessageBox.Save QMessageBox.Cancel QMessageBox.Close QMessageBox.Discard QMessageBox.Apply QMessageBox.Reset QMessageBox.RestoreDefaults QMessageBox.Help QMessageBox.SaveAll QMessageBox.Yes QMessageBox.YesToAll QMessageBox.No QMessageBox.NoToAll QMessageBox.Abort QMessageBox.Retry QMessageBox.Ignore QMessageBox.NoButton Tamb\u00e9 podeu modificar la icona que es mostra al di\u00e0leg configurant la icona amb una de les opcions seg\u00fcents: Icon state Description QMessageBox.NoIcon The message box does not have an icon. QMessageBox.Question The message is asking a question. QMessageBox.Information The message is informational only. QMessageBox.Warning The message is warning. QMessageBox.Critical The message indicates a critical problem. Python 1 2 3 4 5 6 7 8 9 10 11 12 def button_clicked ( self , s ): dlg = QMessageBox ( self ) dlg . setWindowTitle ( \"I have a question!\" ) dlg . setText ( \"This is a question dialog\" ) dlg . setStandardButtons ( QMessageBox . Yes | QMessageBox . No ) dlg . setIcon ( QMessageBox . Question ) button = dlg . exec_ () if button == QMessageBox . Yes : print ( \"Yes!\" ) else : print ( \"No!\" )","title":"Dialegs i alertes"},{"location":"unitats/pyside6/pyside6-dialogs-alerts/#dialegs-i-alertes","text":"","title":"Dialegs i alertes"},{"location":"unitats/pyside6/pyside6-dialogs-alerts/#dialegs","text":"Els di\u00e0legs s\u00f3n components de la GUI \u00fatils que ens permeten comunicar-nos amb l'usuari (d'aqu\u00ed el seu nom). S'utilitzen habitualment per obrir/gurdar fitxers, configuraci\u00f3, prefer\u00e8ncies o per a funcions que no encaixen a la interf\u00edcie principal de l'aplicaci\u00f3. S\u00f3n xicotetes finestres modals (o de bloqueig) que se situen davant de l'aplicaci\u00f3 principal fins que es descarten. Qt ofereix una s\u00e8rie de di\u00e0legs \"especials\" per als casos d'\u00fas m\u00e9s habituals, cosa que ens permet oferir una experi\u00e8ncia d'usuari nativa. A Qt els quadres de di\u00e0leg s\u00f3n gestionats per la classe QDialog. Per crear un quadre de di\u00e0leg nou, simplement creem un nou objecte de tipus QDialog passant un altre widget, per exemple QMainWindow, com a pare. Creem el nostre propi QDialog. Comen\u00e7arem amb una aplicaci\u00f3 simple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): print ( \"click\" , s ) dlg = QDialog ( self ) dlg . setWindowTitle ( \"HELLO!\" ) dlg . exec () app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () A la ranura button_clicked creem la inst\u00e0ncia de di\u00e0leg, passant la nostra inst\u00e0ncia QMainWindow com a pare. Aix\u00f2 far\u00e0 que el di\u00e0leg siga una finestra modal de QMainWindow. Aix\u00f2 significa que el di\u00e0leg bloquejar\u00e0 completament la interacci\u00f3 amb la finestra principal. Una vegada hem creat el di\u00e0leg, l'iniciem amb .exec() - igual que vam fer amb QApplication per crear el bucle d'esdeveniments principal de la nostra aplicaci\u00f3. Aix\u00f2 no \u00e9s una coincid\u00e8ncia: quan executeu el QDialog es crea un bucle d'esdeveniments completament nou, espec\u00edfic per al di\u00e0leg. El QDialog bloqueja completament l'execuci\u00f3 de l'aplicaci\u00f3. No inicieu cap di\u00e0leg i espereu que passe res m\u00e9s en qualsevol altre lloc de la vostra aplicaci\u00f3. M\u00e9s endavant veurem com pots utilitzar fils i processos per esquivar aquest problema. Afegim els botons D'acord i Cancel\u00b7la per permetre a l'usuari acceptar o rebutjar el modal. Per personalitzar el QDialog podem heredar d'ell. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from PySide6.QtWidgets import QDialog , QDialogButtonBox , QVBoxLayout , QLabel class CustomDialog ( QDialog ): def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setWindowTitle ( \"HELLO!\" ) QBtn = QDialogButtonBox . Ok | QDialogButtonBox . Cancel self . buttonBox = QDialogButtonBox ( QBtn ) self . buttonBox . accepted . connect ( self . accept ) self . buttonBox . rejected . connect ( self . reject ) self . layout = QVBoxLayout () message = QLabel ( \"Something happened, is that OK?\" ) self . layout . addWidget ( message ) self . layout . addWidget ( self . buttonBox ) self . setLayout ( self . layout ) Podeu optar per utilitzar un QButton est\u00e0ndard en un disseny, per\u00f2 l'enfocament descrit ac\u00ed garanteix que el vostre di\u00e0leg respecta els est\u00e0ndards de l'escriptori amfitri\u00f3 (d'acord a l'esquerra o a la dreta, per exemple). Jugar amb aquests comportaments pot ser incre\u00efblement molest per als usuaris, aix\u00ed que \u00e9s recomanable consultar la documentaci\u00f3 i seguir les guies d'estil de cada plataforma. El primer pas per crear un quadre de botons de di\u00e0leg \u00e9s definir els botons que es volen mostrar, utilitzant els atributs de QDialogButtonBox. La llista completa de botons disponibles est\u00e0 a continuaci\u00f3: QDialogButtonBox.Ok QDialogButtonBox.Open QDialogButtonBox.Save QDialogButtonBox.Cancel QDialogButtonBox.Close QDialogButtonBox.Discard QDialogButtonBox.Apply QDialogButtonBox.Reset QDialogButtonBox.RestoreDefaults QDialogButtonBox.Help QDialogButtonBox.SaveAll QDialogButtonBox.Yes QDialogButtonBox.YesToAll QDialogButtonBox.No QDialogButtonBox.Abort QDialogButtonBox.Retry QDialogButtonBox.Ignore QDialogButtonBox.NoButton Aquests haurien de ser suficients per crear qualsevol quadre de di\u00e0leg. Podeu construir una l\u00ednia de diversos botons posant-los junts amb el s\u00edmbol | . Qt ho gestionar\u00e0, segons els est\u00e0ndards de la plataforma. Per exemple, per mostrar un bot\u00f3 OK i Cancel\u00b7la hem utilitzat: Python 1 buttons = QDialogButtonBox . Ok | QDialogButtonBox . Cancel La variable buttons ara cont\u00e9 un valor enter que representa aquests dos botons. A continuaci\u00f3, hem de crear la inst\u00e0ncia QDialogButtonBox i la passem com a primer par\u00e0metre. Perqu\u00e8 els botons tinguen algun efecte, heu de connectar els senyals QDialogButtonBox correctes a les ranures del di\u00e0leg. En el nostre cas, hem connectat els senyals accepted i rejected del QDialogButtonBox als controladors de accept i reject de la nostra subclasse de QDialog. Finalment, per fer que el QDialogButtonBox aparega al nostre quadre de di\u00e0leg hem d'afegir-lo al di\u00e0leg. Finalment, iniciem el CustomDialog a la nostra ranura MainWindow.button_clicked . Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QPushButton import customdialog1 class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): # print(\"click\", s) dlg = customdialog1 . CustomDialog ( self ) if dlg . exec (): print ( \"Success!\" ) else : print ( \"Cancel!\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Dialegs"},{"location":"unitats/pyside6/pyside6-dialogs-alerts/#dialegs-amb-missatges-simples-qmessagebox","text":"Hi ha molts di\u00e0legs que segueixen el patr\u00f3 senzill que acabem de veure: un missatge amb botons amb els quals podeu acceptar o cancel\u00b7lar el di\u00e0leg. Tot i que podeu construir aquests di\u00e0legs vosaltres mateixos, Qt tamb\u00e9 proporciona una classe de di\u00e0leg de missatge integrada anomenada QMessageBox. Aix\u00f2 es pot utilitzar per crear di\u00e0legs d'informaci\u00f3, avisos o preguntes. L'exemple seg\u00fcent crea un QMessageBox senzill i el mostra. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QDialog , QMainWindow , QMessageBox , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press me for a dialog!\" ) button . clicked . connect ( self . button_clicked ) self . setCentralWidget ( button ) def button_clicked ( self , s ): dlg = QMessageBox ( self ) dlg . setWindowTitle ( \"I have a question!\" ) dlg . setText ( \"This is a simple dialog\" ) button = dlg . exec_ () if button == QMessageBox . Ok : print ( \"OK!\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () Igual que amb el quadre de botons de di\u00e0leg que ja hem vist, els botons que es mostren en un QMessageBox tamb\u00e9 es configuren amb un conjunt de constants que es poden combinar amb | (l'operador OR binari) per mostrar diversos botons. A continuaci\u00f3 es mostra la llista completa dels tipus de botons disponibles: QMessageBox.Ok QMessageBox.Open QMessageBox.Save QMessageBox.Cancel QMessageBox.Close QMessageBox.Discard QMessageBox.Apply QMessageBox.Reset QMessageBox.RestoreDefaults QMessageBox.Help QMessageBox.SaveAll QMessageBox.Yes QMessageBox.YesToAll QMessageBox.No QMessageBox.NoToAll QMessageBox.Abort QMessageBox.Retry QMessageBox.Ignore QMessageBox.NoButton Tamb\u00e9 podeu modificar la icona que es mostra al di\u00e0leg configurant la icona amb una de les opcions seg\u00fcents: Icon state Description QMessageBox.NoIcon The message box does not have an icon. QMessageBox.Question The message is asking a question. QMessageBox.Information The message is informational only. QMessageBox.Warning The message is warning. QMessageBox.Critical The message indicates a critical problem. Python 1 2 3 4 5 6 7 8 9 10 11 12 def button_clicked ( self , s ): dlg = QMessageBox ( self ) dlg . setWindowTitle ( \"I have a question!\" ) dlg . setText ( \"This is a question dialog\" ) dlg . setStandardButtons ( QMessageBox . Yes | QMessageBox . No ) dlg . setIcon ( QMessageBox . Question ) button = dlg . exec_ () if button == QMessageBox . Yes : print ( \"Yes!\" ) else : print ( \"No!\" )","title":"Di\u00e0legs amb missatges simples (QMessageBox)"},{"location":"unitats/pyside6/pyside6-intro/","text":"Qt i PySide PySide \u00e9s la uni\u00f3 de Python amb el conjunt d'eines per a desenvolupament d'interf\u00edcies gr\u00e0fiques d'usuari multiplataforma Qt, desenvolupat per The Qt Company , com a part del projecte Qt for Python . \u00c9s una de les alternatives al paquet de biblioteca est\u00e0ndard Tkinter. Igual que Qt, PySide \u00e9s programari lliure. PySide \u00e9s compatible amb Linux/X11, macOS i Microsoft Windows. Tot i que hi ha documentaci\u00f3 espec\u00edfica de PySide disponible, tamb\u00e9 podem utilitzar la documentaci\u00f3 de Qt , tenint en compte que s'haur\u00e0 de traduir la sintaxi d'objectes i m\u00e8todes per adaptar-ho a Python. Versions de PySide Hi ha hagut tres versions principals de PySide: PySide \u00e9s compatible amb Qt 4 PySide2 \u00e9s compatible amb Qt 5 PySide6 \u00e9s compatible amb Qt 6 La versi\u00f3 1 de PySide va ser llan\u00e7ada l'agost de 2009 baix llic\u00e8ncia LGPL per Nokia, aleshores propietaria de Qt, despr\u00e9s de no arribar a un acord amb els desenvolupadors de PyQt, Riverbank Computing, per canviar els seus termes de llic\u00e8ncia per incloure LGPL com a llic\u00e8ncia alternativa. Va donar suport a Qt 4 sota els sistemes operatius Linux/X11, Mac OS X, Microsoft Windows, Maemo i MeeGo, mentre que la comunitat PySide va afegir suport per a Android. Christian Tismer va iniciar PySide2 per portar PySide de Qt 4 a Qt 5 el 2015. Aleshores, el projecte es va incorporar al projecte Qt.Va ser llan\u00e7at el desembre de 2018. PySide6 es va llan\u00e7ar el desembre de 2020. Va afegir suport per a Qt 6 i va eliminar el suport per a totes les versions de Python anteriors a la 3.6. El projecte va comen\u00e7ar utilitzant Boost.Python de les biblioteques de Boost C++ per a enlla\u00e7ar el codi Python amb les crides C++, llenguatge sobre el que est\u00e0 contru\u00eft Qt. M\u00e9s tard va crear el seu propi generador d'enlla\u00e7 anomenat Shiboken, per reduir la mida dels executables i l'\u00fas de mem\u00f2ria. Nosaltres farem \u00fas de PySide6 durant el present curs. Instal\u00b7laci\u00f3 de PySide6 Sempre que desenvolupem, hauriem de fer-ho en un entorn virtual. Recordeu que per crear-lo i activar-lo, utilitzem: Python 1 2 3 4 python3 - m venv . venv source . venv / bin / activate #Per a Linux i macOS env \\ Scripts \\ activate . bat #Per a Windows Per a instal\u00b7lar PySide6 utilitzem pip : Bash 1 pip install pyside6 Comprovem la Instal\u00b7laci\u00f3 Una vegada instal\u00b7lat i amb l'entorn virtual activat, podem executar el seg\u00fcent codi per comprovar que tot funciona. Python 1 2 3 4 5 6 7 import PySide6.QtCore # Prints PySide6 version print ( PySide6 . __version__ ) # Prints the Qt version used to compile PySide6 print ( PySide6 . QtCore . __version__ ) Primera aplicaci\u00f3 amb PySide6 - Hola m\u00f3n! Exemple: Hola m\u00f3n! amb PySide6 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from PySide6 import QtWidgets , QtCore # Sols si necessitem arguments importem sys import sys if __name__ == \"__main__\" : # Necessitem una inst\u00e0ncia (i sols una) de QApplication per cada aplicaci\u00f3. # Li passem sys.argv per a permetre arguments des de la l\u00ednia de comandaments # Si no anem a passar arguments podem utilitzar QApplication([]) app = QtWidgets . QApplication ( sys . argv ) # Creem un QLabel amb el text Hola m\u00f3n! i aliniament al centre. label = QtWidgets . QLabel ( \"Hola m\u00f3n!\" , alignment = QtCore . Qt . AlignCenter ) # Redimensionem el QLabel label . resize ( 800 , 600 ) #Fem visible el label IMPORTANT!!!!! Els components estan ocults per defecte. label . show () # Iniciem el bucle d\u2019esdeveniments. sys . exit ( app . exec ()) Si rebeu l'error libOpenGL.so.0: cannot open shared object file: No such file or directory , heu d'instal\u00b7lar la llibreria libopengl0 . sudo apt install libopengl0 -y Baixeu el codi d'ac\u00ed Qu\u00e8 \u00e9s una finestra? Cont\u00e9 la interf\u00edcie de l\u2019usuari Cada aplicaci\u00f3 en necessita almenys una, per\u00f2 en pot tindre m\u00e9s L\u2019aplicaci\u00f3, per defecte, acabar\u00e0 en tancar l\u2019\u00faltima d\u2019elles Qu\u00e8 \u00e9s el bucle d\u2019esdeveniments (event loop)? Ja hem vist que cada aplicaci\u00f3 necessita un i sols un objecte QApplication. Aquest objecte gestiona els esdeveniments. Cada una de les interaccions de l\u2019usuari amb la interf\u00edcie, per exemple, un clic de ratol\u00ed sobre un element, genera un esdeveniment. L\u2019esdeveniment es col\u00b7loca a la cola d\u2019esdeveniments per ser gestionat ( event queue ). Al bucle d'esdeveniments ( event loop ), la cua es comprova a cada iteraci\u00f3 i si es troba un esdeveniment en espera, l'esdeveniment i el control es passen al gestor de l\u2019esdeveniment ( event handler ). El gestor d'esdeveniments s'ocupa de l'esdeveniment i despr\u00e9s passa de nou el control al bucle d'esdeveniments per esperar m\u00e9s esdeveniments. Nom\u00e9s hi ha un bucle d'esdeveniments per aplicaci\u00f3. QMainWindow Es tracta d\u2019un component pre-definit que proporciona moltes funcions est\u00e0ndard de les finestres que fareu servir les vostres aplicacions, com poden ser les barres d'eines, els men\u00fas, la barra d'estat, els components que es poden acoblar, etc. Veurem aquestes funcions avan\u00e7ades m\u00e9s endavant, per\u00f2 de moment anem a fer \u00fas d\u2019ella a la nostra aplicaci\u00f3. Activitat 1 Anem a crear la nostra primera aplicaci\u00f3. Has de definir una classe MainWindow, que herede de QmainWindow. Amb el m\u00e8tode setWindowTitle() posa-li t\u00edtol a l\u2019aplicaci\u00f3 \u00abLa meua aplicaci\u00f3\u00bb. Amb QPushButton(), crea un bot\u00f3 amb el text, \u00abAceptar\u00bb. Afig el bot\u00f3 a la part central de la finestra amb setCentralWidget(\u00abcomponent\u00bb). Recorda mostrar la finestra i iniciar el bucle d\u2019esdeveniments. Activitat 2 Modifica el codi de l\u2019anterior activitat per a que es puga passar per l\u00ednia de comandaments el t\u00edtol i el text del bot\u00f3. Python 1 python3 activitat2 .2 . py \"APP\" \"Text\" Assignem tamany a les finestres i els components Amb la funcions .setFixedSize(amplada, altura) assignem una mida fixa al component sobre el que l\u2019apliquem. Amb .setMinimumSize(amplada, altura) i setMaximumSize(amplada, altura) , assignem les mides m\u00e0ximes i m\u00ednimes, de forma que ni redimensionant amb el ratol\u00ed ni amb els botons de maximitzar i minimitzar tindrem la possibilitat d\u2019establir unes dimensions menors o majors de les establides. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self , title = \"Title\" , button_text = \"Text\" , fixed = False ): super () . __init__ () self . setWindowTitle ( title ) self . button = QPushButton ( button_text ) self . setCentralWidget ( self . button ) #self.setFixedSize(400,600) self . button . setMaximumSize ( 100 , 25 ) self . setMaximumSize ( 400 , 400 ) self . setMinimumSize ( 200 , 200 ) self . button . show () self . show () app = QApplication ( sys . argv ) window = MainWindow () app . exec () Baixa el codi punxant el seg\u00fcent enlla\u00e7 Activitat 3 (entregable) Basant-nos en el codi de l'activitat 2, anem a fer una gesti\u00f3 m\u00e9s pr\u00e0ctica i real dels par\u00e0metres d'entrada de l'script. Este \u00e9s l'aspecte que tindr\u00e0 l'ajuda de l'execuci\u00f3 de l'script. Bash 1 2 3 4 5 6 7 8 9 10 11 usage: finestra3_args.py [ -h ] [ -t TITLE ] [ -b BUTTON_TEXT ] [ -f ] [ -s SIZE SIZE ] optional arguments: -h, --help show this help message and exit -t TITLE, --title TITLE Title of application -b BUTTON_TEXT, --button-text BUTTON_TEXT Button text -f, --fixed-size Window fixed size -s SIZE SIZE, --size SIZE SIZE Size of windows Per a fer tota aquesta gesti\u00f3, busca una llibreria de python que t'ajude.","title":"Introducci\u00f3"},{"location":"unitats/pyside6/pyside6-intro/#qt-i-pyside","text":"PySide \u00e9s la uni\u00f3 de Python amb el conjunt d'eines per a desenvolupament d'interf\u00edcies gr\u00e0fiques d'usuari multiplataforma Qt, desenvolupat per The Qt Company , com a part del projecte Qt for Python . \u00c9s una de les alternatives al paquet de biblioteca est\u00e0ndard Tkinter. Igual que Qt, PySide \u00e9s programari lliure. PySide \u00e9s compatible amb Linux/X11, macOS i Microsoft Windows. Tot i que hi ha documentaci\u00f3 espec\u00edfica de PySide disponible, tamb\u00e9 podem utilitzar la documentaci\u00f3 de Qt , tenint en compte que s'haur\u00e0 de traduir la sintaxi d'objectes i m\u00e8todes per adaptar-ho a Python.","title":"Qt i PySide"},{"location":"unitats/pyside6/pyside6-intro/#versions-de-pyside","text":"Hi ha hagut tres versions principals de PySide: PySide \u00e9s compatible amb Qt 4 PySide2 \u00e9s compatible amb Qt 5 PySide6 \u00e9s compatible amb Qt 6 La versi\u00f3 1 de PySide va ser llan\u00e7ada l'agost de 2009 baix llic\u00e8ncia LGPL per Nokia, aleshores propietaria de Qt, despr\u00e9s de no arribar a un acord amb els desenvolupadors de PyQt, Riverbank Computing, per canviar els seus termes de llic\u00e8ncia per incloure LGPL com a llic\u00e8ncia alternativa. Va donar suport a Qt 4 sota els sistemes operatius Linux/X11, Mac OS X, Microsoft Windows, Maemo i MeeGo, mentre que la comunitat PySide va afegir suport per a Android. Christian Tismer va iniciar PySide2 per portar PySide de Qt 4 a Qt 5 el 2015. Aleshores, el projecte es va incorporar al projecte Qt.Va ser llan\u00e7at el desembre de 2018. PySide6 es va llan\u00e7ar el desembre de 2020. Va afegir suport per a Qt 6 i va eliminar el suport per a totes les versions de Python anteriors a la 3.6. El projecte va comen\u00e7ar utilitzant Boost.Python de les biblioteques de Boost C++ per a enlla\u00e7ar el codi Python amb les crides C++, llenguatge sobre el que est\u00e0 contru\u00eft Qt. M\u00e9s tard va crear el seu propi generador d'enlla\u00e7 anomenat Shiboken, per reduir la mida dels executables i l'\u00fas de mem\u00f2ria. Nosaltres farem \u00fas de PySide6 durant el present curs.","title":"Versions de PySide"},{"location":"unitats/pyside6/pyside6-intro/#installacio-de-pyside6","text":"Sempre que desenvolupem, hauriem de fer-ho en un entorn virtual. Recordeu que per crear-lo i activar-lo, utilitzem: Python 1 2 3 4 python3 - m venv . venv source . venv / bin / activate #Per a Linux i macOS env \\ Scripts \\ activate . bat #Per a Windows Per a instal\u00b7lar PySide6 utilitzem pip : Bash 1 pip install pyside6","title":"Instal\u00b7laci\u00f3 de PySide6"},{"location":"unitats/pyside6/pyside6-intro/#comprovem-la-installacio","text":"Una vegada instal\u00b7lat i amb l'entorn virtual activat, podem executar el seg\u00fcent codi per comprovar que tot funciona. Python 1 2 3 4 5 6 7 import PySide6.QtCore # Prints PySide6 version print ( PySide6 . __version__ ) # Prints the Qt version used to compile PySide6 print ( PySide6 . QtCore . __version__ )","title":"Comprovem la Instal\u00b7laci\u00f3"},{"location":"unitats/pyside6/pyside6-intro/#primera-aplicacio-amb-pyside6-hola-mon","text":"","title":"Primera aplicaci\u00f3 amb PySide6 - Hola m\u00f3n!"},{"location":"unitats/pyside6/pyside6-intro/#exemple-hola-mon-amb-pyside6","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from PySide6 import QtWidgets , QtCore # Sols si necessitem arguments importem sys import sys if __name__ == \"__main__\" : # Necessitem una inst\u00e0ncia (i sols una) de QApplication per cada aplicaci\u00f3. # Li passem sys.argv per a permetre arguments des de la l\u00ednia de comandaments # Si no anem a passar arguments podem utilitzar QApplication([]) app = QtWidgets . QApplication ( sys . argv ) # Creem un QLabel amb el text Hola m\u00f3n! i aliniament al centre. label = QtWidgets . QLabel ( \"Hola m\u00f3n!\" , alignment = QtCore . Qt . AlignCenter ) # Redimensionem el QLabel label . resize ( 800 , 600 ) #Fem visible el label IMPORTANT!!!!! Els components estan ocults per defecte. label . show () # Iniciem el bucle d\u2019esdeveniments. sys . exit ( app . exec ()) Si rebeu l'error libOpenGL.so.0: cannot open shared object file: No such file or directory , heu d'instal\u00b7lar la llibreria libopengl0 . sudo apt install libopengl0 -y Baixeu el codi d'ac\u00ed","title":"Exemple: Hola m\u00f3n! amb PySide6"},{"location":"unitats/pyside6/pyside6-intro/#que-es-una-finestra","text":"Cont\u00e9 la interf\u00edcie de l\u2019usuari Cada aplicaci\u00f3 en necessita almenys una, per\u00f2 en pot tindre m\u00e9s L\u2019aplicaci\u00f3, per defecte, acabar\u00e0 en tancar l\u2019\u00faltima d\u2019elles","title":"Qu\u00e8 \u00e9s una finestra?"},{"location":"unitats/pyside6/pyside6-intro/#que-es-el-bucle-desdeveniments-event-loop","text":"Ja hem vist que cada aplicaci\u00f3 necessita un i sols un objecte QApplication. Aquest objecte gestiona els esdeveniments. Cada una de les interaccions de l\u2019usuari amb la interf\u00edcie, per exemple, un clic de ratol\u00ed sobre un element, genera un esdeveniment. L\u2019esdeveniment es col\u00b7loca a la cola d\u2019esdeveniments per ser gestionat ( event queue ). Al bucle d'esdeveniments ( event loop ), la cua es comprova a cada iteraci\u00f3 i si es troba un esdeveniment en espera, l'esdeveniment i el control es passen al gestor de l\u2019esdeveniment ( event handler ). El gestor d'esdeveniments s'ocupa de l'esdeveniment i despr\u00e9s passa de nou el control al bucle d'esdeveniments per esperar m\u00e9s esdeveniments. Nom\u00e9s hi ha un bucle d'esdeveniments per aplicaci\u00f3.","title":"Qu\u00e8 \u00e9s el bucle d\u2019esdeveniments (event loop)?"},{"location":"unitats/pyside6/pyside6-intro/#qmainwindow","text":"Es tracta d\u2019un component pre-definit que proporciona moltes funcions est\u00e0ndard de les finestres que fareu servir les vostres aplicacions, com poden ser les barres d'eines, els men\u00fas, la barra d'estat, els components que es poden acoblar, etc. Veurem aquestes funcions avan\u00e7ades m\u00e9s endavant, per\u00f2 de moment anem a fer \u00fas d\u2019ella a la nostra aplicaci\u00f3.","title":"QMainWindow"},{"location":"unitats/pyside6/pyside6-intro/#activitat-1","text":"Anem a crear la nostra primera aplicaci\u00f3. Has de definir una classe MainWindow, que herede de QmainWindow. Amb el m\u00e8tode setWindowTitle() posa-li t\u00edtol a l\u2019aplicaci\u00f3 \u00abLa meua aplicaci\u00f3\u00bb. Amb QPushButton(), crea un bot\u00f3 amb el text, \u00abAceptar\u00bb. Afig el bot\u00f3 a la part central de la finestra amb setCentralWidget(\u00abcomponent\u00bb). Recorda mostrar la finestra i iniciar el bucle d\u2019esdeveniments.","title":"Activitat 1"},{"location":"unitats/pyside6/pyside6-intro/#activitat-2","text":"Modifica el codi de l\u2019anterior activitat per a que es puga passar per l\u00ednia de comandaments el t\u00edtol i el text del bot\u00f3. Python 1 python3 activitat2 .2 . py \"APP\" \"Text\"","title":"Activitat 2"},{"location":"unitats/pyside6/pyside6-intro/#assignem-tamany-a-les-finestres-i-els-components","text":"Amb la funcions .setFixedSize(amplada, altura) assignem una mida fixa al component sobre el que l\u2019apliquem. Amb .setMinimumSize(amplada, altura) i setMaximumSize(amplada, altura) , assignem les mides m\u00e0ximes i m\u00ednimes, de forma que ni redimensionant amb el ratol\u00ed ni amb els botons de maximitzar i minimitzar tindrem la possibilitat d\u2019establir unes dimensions menors o majors de les establides. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self , title = \"Title\" , button_text = \"Text\" , fixed = False ): super () . __init__ () self . setWindowTitle ( title ) self . button = QPushButton ( button_text ) self . setCentralWidget ( self . button ) #self.setFixedSize(400,600) self . button . setMaximumSize ( 100 , 25 ) self . setMaximumSize ( 400 , 400 ) self . setMinimumSize ( 200 , 200 ) self . button . show () self . show () app = QApplication ( sys . argv ) window = MainWindow () app . exec () Baixa el codi punxant el seg\u00fcent enlla\u00e7","title":"Assignem tamany a les finestres i els components"},{"location":"unitats/pyside6/pyside6-intro/#activitat-3-entregable","text":"Basant-nos en el codi de l'activitat 2, anem a fer una gesti\u00f3 m\u00e9s pr\u00e0ctica i real dels par\u00e0metres d'entrada de l'script. Este \u00e9s l'aspecte que tindr\u00e0 l'ajuda de l'execuci\u00f3 de l'script. Bash 1 2 3 4 5 6 7 8 9 10 11 usage: finestra3_args.py [ -h ] [ -t TITLE ] [ -b BUTTON_TEXT ] [ -f ] [ -s SIZE SIZE ] optional arguments: -h, --help show this help message and exit -t TITLE, --title TITLE Title of application -b BUTTON_TEXT, --button-text BUTTON_TEXT Button text -f, --fixed-size Window fixed size -s SIZE SIZE, --size SIZE SIZE Size of windows Per a fer tota aquesta gesti\u00f3, busca una llibreria de python que t'ajude.","title":"Activitat 3 (entregable)"},{"location":"unitats/pyside6/pyside6-layouts/","text":"Gesti\u00f3 del layout Fins ara hem creat una finestra i hi hem afegit un widget . Tanmateix, normalment volem afegir m\u00e9s d'un widget a una finestra i tenir cert control sobre on va a parar. Per fer-ho a Qt fem servir layouts . Hi ha 4 dissenys b\u00e0sics disponibles a Qt, que s'enumeren a la taula seg\u00fcent. Layout Comportament QHBoxLayout Disseny horitzontal QVBoxLayout Disseny vertical QGridLayout Disseny de graella indexable XxY QStackedLayout Apilats en profunditat Com podeu veure, hi ha tres dissenys posicionals disponibles a Qt. El VBoxLayout, QHBoxLayout i QGridLayout. A m\u00e9s, tamb\u00e9 hi ha QStackedLayout que us permet col\u00b7locar widgets un damunt de l'altre dins del mateix espai, tot i que mostra nom\u00e9s un layout alhora. M\u00e9s endavant utilitzarem uns ferramenta gr\u00e0fica per definir el layout . Classe Color Per facilitar la visualitzaci\u00f3 dels dissenys, primer crearem un widget personalitzat senzill que mostre un color s\u00f2lid que triem. Aix\u00f2 ajudar\u00e0 a distingir els widgets que afegim al disseny. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 from PySide6.QtGui import QPalette , QColor from PySide6.QtWidgets import QWidget class Color ( QWidget ): def __init__ ( self , color ): super ( Color , self ) . __init__ () self . setAutoFillBackground ( True ) palette = self . palette () palette . setColor ( QPalette . Window , QColor ( color )) self . setPalette ( palette ) En aquest codi subclassem QWidget per crear el nostre propi widget personalitzat Color. Acceptem un \u00fanic par\u00e0metre a l'hora de crear un objecte Color: Color(un str). Primer establim . setAutoFillBackground a True per dir-li al widget que ompliga autom\u00e0ticament el seu fons amb el color que li hem passat. A continuaci\u00f3, obtenim la paleta actual (que \u00e9s la paleta global de l'escriptori per defecte) i canviem el color QPalette.Window actual a un nou QColor descrit pel color del valor que hem passat. Finalment, tornem a aplicar aquesta paleta al widget . El resultat final \u00e9s un widget que s'omple amb un color s\u00f2lid, qu\u00e8 vam especificar quan el vam crear. M\u00e9s endavant tractarem els widget s personalitzats amb m\u00e9s detall. Podeu establir l'espaiat al voltant del disseny amb .setContentMargins o establir l'espai entre elements amb .setSpacing . QVBoxLayout El layout vertical va afegint els widgets un damunt de l'altre. Si afegim un nou widget l'afegir\u00e0 a la part de baix. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QVBoxLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QVBoxLayout () layout . addWidget ( Color ( 'red' )) layout . addWidget ( Color ( 'green' )) layout . addWidget ( Color ( 'blue' )) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () QHBoxLayout El layout horitzontal va afegint els components un al costat de l'altre. Si afegim un nou component, l'afegir\u00e0 a l'esquerra. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QHBoxLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QHBoxLayout () layout . addWidget ( Color ( 'red' )) layout . addWidget ( Color ( 'green' )) layout . addWidget ( Color ( 'blue' )) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Layouts anidats Per a dissenys m\u00e9s complexos, podem niuar els dissenys els uns dintre dels altres mitjan\u00e7ant .addLayout en un disseny. A continuaci\u00f3, afegim un QVBoxLayout al QHBoxLayout principal. Si afegim alguns widgets al QVBoxLayout , estaran disposats verticalment a la primera ranura del disseny principal. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import sys from PySide6.QtWidgets import ( QApplication , QMainWindow , QWidget , QHBoxLayout , QVBoxLayout ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout1 = QHBoxLayout () layout2 = QVBoxLayout () layout3 = QVBoxLayout () layout1 . setContentsMargins ( 0 , 0 , 0 , 0 ) layout1 . setSpacing ( 0 ) layout2 . addWidget ( Color ( 'red' )) layout2 . addWidget ( Color ( 'yellow' )) layout2 . addWidget ( Color ( 'purple' )) layout1 . addLayout ( layout2 ) layout1 . addWidget ( Color ( 'green' )) layout3 . addWidget ( Color ( 'red' )) layout3 . addWidget ( Color ( 'purple' )) layout1 . addLayout ( layout3 ) widget = QWidget () widget . setLayout ( layout1 ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () QGridLayout Per molt \u00fatils que siguen, si proveu d'utilitzar QVBoxLayout i QHBoxLayout per dissenyar diversos elements, per exemple a un formulari, us ser\u00e0 molt dif\u00edcil assegurar-vos que els components de mida diferent s'alinein. La soluci\u00f3 a aix\u00f2 \u00e9s QGridLayout . QGridLayout us permet posicionar elements espec\u00edficament en una quadr\u00edcula. Especifiqueu les posicions de fila i columna per a cada component. Podeu ometre elements i es deixaran buits. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QGridLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QGridLayout () layout . addWidget ( Color ( 'red' ), 0 , 0 ) layout . addWidget ( Color ( 'green' ), 1 , 0 ) layout . addWidget ( Color ( 'blue' ), 1 , 1 ) layout . addWidget ( Color ( 'purple' ), 2 , 1 ) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () QStackedLayout El disseny final que tractarem \u00e9s el QStackedLayout. Tal com es descriu, aquest disseny us permet col\u00b7locar elements directament els uns damunt dels altres (apilats). A continuaci\u00f3, podeu seleccionar quin disseny voleu mostrar. Podeu utilitzar-lo per dibuixar capes en una aplicaci\u00f3 gr\u00e0fica o per imitar una interf\u00edcie semblant a una pestanya. Tingueu en compte que tamb\u00e9 hi ha QStackedWidget , que \u00e9s un component de contenidor que funciona exactament de la mateixa manera. Aix\u00f2 \u00e9s \u00fatil si voleu afegir una pila de components directament a un QMainWindow amb setCentralWidget . QStackedWidget \u00e9s exactament com funcionen les vistes amb pestanyes a les aplicacions. Nom\u00e9s una pestanya \u00e9s visible alhora. Podeu controlar quin components mostrar en qualsevol moment utilitzant .setCurrentIndex() o .setCurrentWidget() per establir l'element mitjan\u00e7ant l'\u00edndex o per la refer\u00e8ncia al propi component. A continuaci\u00f3 es mostra una breu demostraci\u00f3 amb QStackedLayout en combinaci\u00f3 amb QButton per proporcionar una interf\u00edcie semblant a una pestanya a una aplicaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QHBoxLayout , QLabel , QMainWindow , QPushButton , QStackedLayout , QVBoxLayout , QWidget , ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) pagelayout = QVBoxLayout () button_layout = QHBoxLayout () self . stacklayout = QStackedLayout () pagelayout . addLayout ( button_layout ) pagelayout . addLayout ( self . stacklayout ) btn = QPushButton ( \"red\" ) btn . pressed . connect ( self . activate_tab_1 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"red\" )) btn = QPushButton ( \"green\" ) btn . pressed . connect ( self . activate_tab_2 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"green\" )) btn = QPushButton ( \"yellow\" ) btn . pressed . connect ( self . activate_tab_3 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"yellow\" )) widget = QWidget () widget . setLayout ( pagelayout ) self . setCentralWidget ( widget ) def activate_tab_1 ( self ): self . stacklayout . setCurrentIndex ( 0 ) def activate_tab_2 ( self ): self . stacklayout . setCurrentIndex ( 1 ) def activate_tab_3 ( self ): self . stacklayout . setCurrentIndex ( 2 ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () El resultat \u00e9s la seg\u00fcent aplicaci\u00f3: QTabWidget Qt en realitat proporciona un TabWidget que proporciona aquest tipus de disseny en forma de widget. Vegeu el seg\u00fcent exemple amb QTabWidget: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QLabel , QMainWindow , QPushButton , QTabWidget , QWidget , ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) tabs = QTabWidget () tabs . setTabPosition ( QTabWidget . West ) tabs . setMovable ( True ) for n , color in enumerate ([ \"red\" , \"green\" , \"blue\" , \"yellow\" ]): tabs . addTab ( Color ( color ), color ) self . setCentralWidget ( tabs ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Com podeu veure, \u00e9s una mica m\u00e9s senzill i una mica m\u00e9s atractiu! Podeu establir la posici\u00f3 de les pestanyes mitjan\u00e7ant les direccions cardinals, canviar si les pestanyes es poden moure amb .setMoveable . Notareu que la barra de pestanyes de macOS t\u00e9 un aspecte molt diferent de les altres; de manera predeterminada, les pestanyes de macOS adopten un estil de pastilla o bombolla. A macOS, normalment s'utilitza per als panells de configuraci\u00f3 amb pestanyes. Per als documents, podeu activar el mode de document per oferir pestanyes esveltes semblants a les que veieu a altres plataformes. Aquesta opci\u00f3 no t\u00e9 cap efecte en altres plataformes.","title":"Layouts"},{"location":"unitats/pyside6/pyside6-layouts/#gestio-del-layout","text":"Fins ara hem creat una finestra i hi hem afegit un widget . Tanmateix, normalment volem afegir m\u00e9s d'un widget a una finestra i tenir cert control sobre on va a parar. Per fer-ho a Qt fem servir layouts . Hi ha 4 dissenys b\u00e0sics disponibles a Qt, que s'enumeren a la taula seg\u00fcent. Layout Comportament QHBoxLayout Disseny horitzontal QVBoxLayout Disseny vertical QGridLayout Disseny de graella indexable XxY QStackedLayout Apilats en profunditat Com podeu veure, hi ha tres dissenys posicionals disponibles a Qt. El VBoxLayout, QHBoxLayout i QGridLayout. A m\u00e9s, tamb\u00e9 hi ha QStackedLayout que us permet col\u00b7locar widgets un damunt de l'altre dins del mateix espai, tot i que mostra nom\u00e9s un layout alhora. M\u00e9s endavant utilitzarem uns ferramenta gr\u00e0fica per definir el layout .","title":"Gesti\u00f3 del layout"},{"location":"unitats/pyside6/pyside6-layouts/#classe-color","text":"Per facilitar la visualitzaci\u00f3 dels dissenys, primer crearem un widget personalitzat senzill que mostre un color s\u00f2lid que triem. Aix\u00f2 ajudar\u00e0 a distingir els widgets que afegim al disseny. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 from PySide6.QtGui import QPalette , QColor from PySide6.QtWidgets import QWidget class Color ( QWidget ): def __init__ ( self , color ): super ( Color , self ) . __init__ () self . setAutoFillBackground ( True ) palette = self . palette () palette . setColor ( QPalette . Window , QColor ( color )) self . setPalette ( palette ) En aquest codi subclassem QWidget per crear el nostre propi widget personalitzat Color. Acceptem un \u00fanic par\u00e0metre a l'hora de crear un objecte Color: Color(un str). Primer establim . setAutoFillBackground a True per dir-li al widget que ompliga autom\u00e0ticament el seu fons amb el color que li hem passat. A continuaci\u00f3, obtenim la paleta actual (que \u00e9s la paleta global de l'escriptori per defecte) i canviem el color QPalette.Window actual a un nou QColor descrit pel color del valor que hem passat. Finalment, tornem a aplicar aquesta paleta al widget . El resultat final \u00e9s un widget que s'omple amb un color s\u00f2lid, qu\u00e8 vam especificar quan el vam crear. M\u00e9s endavant tractarem els widget s personalitzats amb m\u00e9s detall. Podeu establir l'espaiat al voltant del disseny amb .setContentMargins o establir l'espai entre elements amb .setSpacing .","title":"Classe Color"},{"location":"unitats/pyside6/pyside6-layouts/#qvboxlayout","text":"El layout vertical va afegint els widgets un damunt de l'altre. Si afegim un nou widget l'afegir\u00e0 a la part de baix. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QVBoxLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QVBoxLayout () layout . addWidget ( Color ( 'red' )) layout . addWidget ( Color ( 'green' )) layout . addWidget ( Color ( 'blue' )) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"QVBoxLayout"},{"location":"unitats/pyside6/pyside6-layouts/#qhboxlayout","text":"El layout horitzontal va afegint els components un al costat de l'altre. Si afegim un nou component, l'afegir\u00e0 a l'esquerra. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QHBoxLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QHBoxLayout () layout . addWidget ( Color ( 'red' )) layout . addWidget ( Color ( 'green' )) layout . addWidget ( Color ( 'blue' )) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"QHBoxLayout"},{"location":"unitats/pyside6/pyside6-layouts/#layouts-anidats","text":"Per a dissenys m\u00e9s complexos, podem niuar els dissenys els uns dintre dels altres mitjan\u00e7ant .addLayout en un disseny. A continuaci\u00f3, afegim un QVBoxLayout al QHBoxLayout principal. Si afegim alguns widgets al QVBoxLayout , estaran disposats verticalment a la primera ranura del disseny principal. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import sys from PySide6.QtWidgets import ( QApplication , QMainWindow , QWidget , QHBoxLayout , QVBoxLayout ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout1 = QHBoxLayout () layout2 = QVBoxLayout () layout3 = QVBoxLayout () layout1 . setContentsMargins ( 0 , 0 , 0 , 0 ) layout1 . setSpacing ( 0 ) layout2 . addWidget ( Color ( 'red' )) layout2 . addWidget ( Color ( 'yellow' )) layout2 . addWidget ( Color ( 'purple' )) layout1 . addLayout ( layout2 ) layout1 . addWidget ( Color ( 'green' )) layout3 . addWidget ( Color ( 'red' )) layout3 . addWidget ( Color ( 'purple' )) layout1 . addLayout ( layout3 ) widget = QWidget () widget . setLayout ( layout1 ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Layouts anidats"},{"location":"unitats/pyside6/pyside6-layouts/#qgridlayout","text":"Per molt \u00fatils que siguen, si proveu d'utilitzar QVBoxLayout i QHBoxLayout per dissenyar diversos elements, per exemple a un formulari, us ser\u00e0 molt dif\u00edcil assegurar-vos que els components de mida diferent s'alinein. La soluci\u00f3 a aix\u00f2 \u00e9s QGridLayout . QGridLayout us permet posicionar elements espec\u00edficament en una quadr\u00edcula. Especifiqueu les posicions de fila i columna per a cada component. Podeu ometre elements i es deixaran buits. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QWidget , QGridLayout from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) layout = QGridLayout () layout . addWidget ( Color ( 'red' ), 0 , 0 ) layout . addWidget ( Color ( 'green' ), 1 , 0 ) layout . addWidget ( Color ( 'blue' ), 1 , 1 ) layout . addWidget ( Color ( 'purple' ), 2 , 1 ) widget = QWidget () widget . setLayout ( layout ) self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"QGridLayout"},{"location":"unitats/pyside6/pyside6-layouts/#qstackedlayout","text":"El disseny final que tractarem \u00e9s el QStackedLayout. Tal com es descriu, aquest disseny us permet col\u00b7locar elements directament els uns damunt dels altres (apilats). A continuaci\u00f3, podeu seleccionar quin disseny voleu mostrar. Podeu utilitzar-lo per dibuixar capes en una aplicaci\u00f3 gr\u00e0fica o per imitar una interf\u00edcie semblant a una pestanya. Tingueu en compte que tamb\u00e9 hi ha QStackedWidget , que \u00e9s un component de contenidor que funciona exactament de la mateixa manera. Aix\u00f2 \u00e9s \u00fatil si voleu afegir una pila de components directament a un QMainWindow amb setCentralWidget . QStackedWidget \u00e9s exactament com funcionen les vistes amb pestanyes a les aplicacions. Nom\u00e9s una pestanya \u00e9s visible alhora. Podeu controlar quin components mostrar en qualsevol moment utilitzant .setCurrentIndex() o .setCurrentWidget() per establir l'element mitjan\u00e7ant l'\u00edndex o per la refer\u00e8ncia al propi component. A continuaci\u00f3 es mostra una breu demostraci\u00f3 amb QStackedLayout en combinaci\u00f3 amb QButton per proporcionar una interf\u00edcie semblant a una pestanya a una aplicaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QHBoxLayout , QLabel , QMainWindow , QPushButton , QStackedLayout , QVBoxLayout , QWidget , ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) pagelayout = QVBoxLayout () button_layout = QHBoxLayout () self . stacklayout = QStackedLayout () pagelayout . addLayout ( button_layout ) pagelayout . addLayout ( self . stacklayout ) btn = QPushButton ( \"red\" ) btn . pressed . connect ( self . activate_tab_1 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"red\" )) btn = QPushButton ( \"green\" ) btn . pressed . connect ( self . activate_tab_2 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"green\" )) btn = QPushButton ( \"yellow\" ) btn . pressed . connect ( self . activate_tab_3 ) button_layout . addWidget ( btn ) self . stacklayout . addWidget ( Color ( \"yellow\" )) widget = QWidget () widget . setLayout ( pagelayout ) self . setCentralWidget ( widget ) def activate_tab_1 ( self ): self . stacklayout . setCurrentIndex ( 0 ) def activate_tab_2 ( self ): self . stacklayout . setCurrentIndex ( 1 ) def activate_tab_3 ( self ): self . stacklayout . setCurrentIndex ( 2 ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () El resultat \u00e9s la seg\u00fcent aplicaci\u00f3:","title":"QStackedLayout"},{"location":"unitats/pyside6/pyside6-layouts/#qtabwidget","text":"Qt en realitat proporciona un TabWidget que proporciona aquest tipus de disseny en forma de widget. Vegeu el seg\u00fcent exemple amb QTabWidget: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QLabel , QMainWindow , QPushButton , QTabWidget , QWidget , ) from color_widget import Color class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) tabs = QTabWidget () tabs . setTabPosition ( QTabWidget . West ) tabs . setMovable ( True ) for n , color in enumerate ([ \"red\" , \"green\" , \"blue\" , \"yellow\" ]): tabs . addTab ( Color ( color ), color ) self . setCentralWidget ( tabs ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Com podeu veure, \u00e9s una mica m\u00e9s senzill i una mica m\u00e9s atractiu! Podeu establir la posici\u00f3 de les pestanyes mitjan\u00e7ant les direccions cardinals, canviar si les pestanyes es poden moure amb .setMoveable . Notareu que la barra de pestanyes de macOS t\u00e9 un aspecte molt diferent de les altres; de manera predeterminada, les pestanyes de macOS adopten un estil de pastilla o bombolla. A macOS, normalment s'utilitza per als panells de configuraci\u00f3 amb pestanyes. Per als documents, podeu activar el mode de document per oferir pestanyes esveltes semblants a les que veieu a altres plataformes. Aquesta opci\u00f3 no t\u00e9 cap efecte en altres plataformes.","title":"QTabWidget"},{"location":"unitats/pyside6/pyside6-menu-actions/","text":"Accions: barres de ferramentes i men\u00fas A continuaci\u00f3, veurem alguns dels elements comuns de la interf\u00edcie d'usuari, que probablement heu vist en moltes altres aplicacions: barres d'eines i men\u00fas. Farem \u00fas de QAction per a evitar duplicitat entre diferents parts de la interf\u00edcie. Barres d'eines ( tool bar ) Un dels elements de la interf\u00edcie d'usuari m\u00e9s comuna \u00e9s la barra de ferramentes. S\u00f3n barres d'icones i/o text que s'utilitzen per realitzar tasques habituals dins d'una aplicaci\u00f3, per a les quals l'acc\u00e9s mitjan\u00e7ant un men\u00fa seria complicat. S\u00f3n una de les funcions d'interf\u00edcie d'usuari m\u00e9s comunes que es veuen en moltes aplicacions. Tot i que algunes aplicacions complexes, especialment a la suite de Microsoft Office, han migrat a interf\u00edcies de \"men\u00fa\" contextuals, la barra d'eines est\u00e0ndard sol ser suficient per a la majoria d'aplicacions que creareu. Normalment es proporciona una interf\u00edcie alternativa als men\u00fas per activar i desactivar les barres d'eines. QAction QAction \u00e9s una classe que proporciona una manera de descriure interf\u00edcies d'usuari abstractes. Aix\u00f2 significa que podeu definir diversos elements d'interf\u00edcie dins d'un \u00fanic objecte, unificats per l'efecte que t\u00e9 la interacci\u00f3 amb aquest element. Per exemple, \u00e9s com\u00fa tindre funcions que es representen a la barra d'eines, per\u00f2 tamb\u00e9 al men\u00fa; penseu en alguna cosa com Edita->Retallar que est\u00e0 present tant al men\u00fa Edita com tamb\u00e9 a la barra d'eines com unes tisores, i tamb\u00e9 a trav\u00e9s de la drecera de teclat Ctrl-X (Cmd-X a Mac). Sense QAction haur\u00edeu de definir-ho en diversos llocs. Per\u00f2 amb QAction podeu definir una \u00fanica QAction, definint l'acci\u00f3 activada i despr\u00e9s afegir aquesta acci\u00f3 tant al men\u00fa com a la barra d'eines. Cada QAction t\u00e9 noms, missatges d'estat, icones i senyals als quals us podeu subscriure. Al codi seg\u00fcent podeu veure aquesta primera QAction a una barra de ferramentes. Exemple Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sys from PySide6.QtWidgets import ( QMainWindow , QApplication , QLabel , QToolBar ) from PySide6.QtGui import QAction from PySide6.QtCore import Qt class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My Awesome App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) self . addToolBar ( toolbar ) button_action = QAction ( \"Your button\" , self ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) toolbar . addAction ( button_action ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Barra d'estat ( status bar ) En el seg\u00fcent exemple creem una barra d'estat i l'afegim a la finestra principal. En passar el ratol\u00ed per damunt el bot\u00f3 de la barra d'estat, es mostra el text definit a la barra d'estats. Exemple Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import sys import os from PySide6.QtWidgets import ( QMainWindow , QApplication , QLabel , QToolBar , QStatusBar ) from PySide6.QtGui import QAction , QIcon from PySide6.QtCore import Qt , QSize class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My Awesome App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) self . setStatusBar ( QStatusBar ( self )) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Podem configurar l'action per a transformar el bot\u00f3 en un polsador. A m\u00e9s, tamb\u00e9 podem afegir una icona i configurar la posici\u00f3 del text que acompanya a aquesta icona segons els valors de la taula seg\u00fcents: Flag Comportament Qt.ToolButtonIconOnly Icona sola, sense text Qt.ToolButtonTextOnly Text sol, sense icona Qt.ToolButtonTextBesideIcon Icona i text, amb el text al costat de la icona Qt.ToolButtonTextUnderIcon Icona i text, amb el text baix de la icona Qt.ToolButtonFollowStyle Seguir l'estil de la configuraci\u00f3 de l'escriptori El valor predeterminat \u00e9s Qt.ToolButtonFollowStyle, el que significa que la vostra aplicaci\u00f3 seguir\u00e0 per defecte la configuraci\u00f3 est\u00e0ndard/global per a l'escriptori on s'executa l'aplicaci\u00f3. Aix\u00f2 es recomana generalment perqu\u00e8 la vostra aplicaci\u00f3 s'integre millor i es senta el m\u00e9s nativa possible. Finalment, afegirem un segon bot\u00f3 i un checkbox a la barra de ferramentes. Podeu posar qualsevol component. Podeu accedir a icones publicades baix CC al seg\u00fcent enlla\u00e7 Men\u00fas Els men\u00fas s\u00f3n un altre component est\u00e0ndard de les interf\u00edcies d'usuari. Normalment es troben a la part superior de la finestra o a la part superior d'una pantalla a macOS. Permeten l'acc\u00e9s a totes les funcions est\u00e0ndard de l'aplicaci\u00f3. Hi ha uns quants men\u00fas est\u00e0ndard, per exemple Fitxer, Edita, Ajuda. Els men\u00fas es poden anidar per crear arbres jer\u00e0rquics de funcions i sovint admeten i mostren dreceres de teclat per accedir r\u00e0pidament a les seves funcions. Per crear un men\u00fa, creem una barra de men\u00fas que anomenem .menuBar() a QMainWindow. Afegim un men\u00fa a la nostra barra de men\u00fas cridant a .addMenu() , passant el nom del men\u00fa. En este cas l'hem anomenat \"&Fitxer\". El ampersand defineix una tecla r\u00e0pida per mostrar aquest men\u00fa en pr\u00e9mer Alt. Aix\u00f2 no ser\u00e0 visible a macOS. Tingueu en compte que no estem definint una drecera de teclat. Ac\u00ed \u00e9s on entra en joc el poder de les accions. Podem reutilitzar el QAction ja existent per afegir la mateixa funci\u00f3 al men\u00fa. Per afegir una acci\u00f3, cridem a .addAction() passant en una de les nostres accions definides. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Feu clic a l'element del men\u00fa i notareu que es pot alternar com un polsador: hereta les caracter\u00edstiques de QAction. En este segon exemple, afegim algunes coses m\u00e9s al men\u00fa. Afegirem un separador al men\u00fa, que apareixer\u00e0 com una l\u00ednia horitzontal al men\u00fa, i despr\u00e9s afegirem la segona QAction que hem creat. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_menu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Tamb\u00e9 podeu fer servir un ampersand per afegir tecles d'acceleraci\u00f3 al men\u00fa per permetre que una sola tecla s'utilitzi per anar a un element del men\u00fa quan estiga obert . De nou, aix\u00f2 no funciona a macOS. Per afegir un submen\u00fa, nom\u00e9s cal que creeu un nou men\u00fa cridant a addMenu() al men\u00fa principal. A continuaci\u00f3, podeu afegir accions amb normalitat. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_menu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Dreceres de teclat Finalment afegirem una drecera de teclat a QAction. Definim una drecera de teclat passant setKeySequence() i passant la seq\u00fc\u00e8ncia de tecles. Qualsevol seq\u00fc\u00e8ncia de tecles definida apareixer\u00e0 al men\u00fa. Tingueu en compte que la drecera de teclat est\u00e0 associada amb el QAction i seguir\u00e0 funcionant tant si el QAction s'afegeix o no a un men\u00fa o a una barra d'eines. Les dreceres de teclat es poden definir de diverses maneres, ja sigui passant com a text, utilitzant noms de tecles o utilitzant les seq\u00fc\u00e8ncies de tecles definides. Utilitzeu aquest \u00faltim sempre que pugueu per garantir el compliment dels est\u00e0ndards del sistema operatiu. Exemple Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon , QKeySequence from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) # The `Qt` namespace has a lot of attributes to customize # widgets. See: http://doc.qt.io/qt-5/qt.html label . setAlignment ( Qt . AlignCenter ) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) # You can enter keyboard shortcuts using key names (e.g. Ctrl+p) # Qt.namespace identifiers (e.g. Qt.CTRL + Qt.Key_P) # or system agnostic identifiers (e.g. QKeySequence.Print) button_action . setShortcut ( QKeySequence ( \"Ctrl+p\" )) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_submenu = file_menu . addMenu ( \"Submenu\" ) file_submenu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Men\u00fas, barres de ferramentes i barres d'estat"},{"location":"unitats/pyside6/pyside6-menu-actions/#accions-barres-de-ferramentes-i-menus","text":"A continuaci\u00f3, veurem alguns dels elements comuns de la interf\u00edcie d'usuari, que probablement heu vist en moltes altres aplicacions: barres d'eines i men\u00fas. Farem \u00fas de QAction per a evitar duplicitat entre diferents parts de la interf\u00edcie.","title":"Accions: barres de ferramentes i men\u00fas"},{"location":"unitats/pyside6/pyside6-menu-actions/#barres-deines-tool-bar","text":"Un dels elements de la interf\u00edcie d'usuari m\u00e9s comuna \u00e9s la barra de ferramentes. S\u00f3n barres d'icones i/o text que s'utilitzen per realitzar tasques habituals dins d'una aplicaci\u00f3, per a les quals l'acc\u00e9s mitjan\u00e7ant un men\u00fa seria complicat. S\u00f3n una de les funcions d'interf\u00edcie d'usuari m\u00e9s comunes que es veuen en moltes aplicacions. Tot i que algunes aplicacions complexes, especialment a la suite de Microsoft Office, han migrat a interf\u00edcies de \"men\u00fa\" contextuals, la barra d'eines est\u00e0ndard sol ser suficient per a la majoria d'aplicacions que creareu. Normalment es proporciona una interf\u00edcie alternativa als men\u00fas per activar i desactivar les barres d'eines.","title":"Barres d'eines (tool bar)"},{"location":"unitats/pyside6/pyside6-menu-actions/#qaction","text":"QAction \u00e9s una classe que proporciona una manera de descriure interf\u00edcies d'usuari abstractes. Aix\u00f2 significa que podeu definir diversos elements d'interf\u00edcie dins d'un \u00fanic objecte, unificats per l'efecte que t\u00e9 la interacci\u00f3 amb aquest element. Per exemple, \u00e9s com\u00fa tindre funcions que es representen a la barra d'eines, per\u00f2 tamb\u00e9 al men\u00fa; penseu en alguna cosa com Edita->Retallar que est\u00e0 present tant al men\u00fa Edita com tamb\u00e9 a la barra d'eines com unes tisores, i tamb\u00e9 a trav\u00e9s de la drecera de teclat Ctrl-X (Cmd-X a Mac). Sense QAction haur\u00edeu de definir-ho en diversos llocs. Per\u00f2 amb QAction podeu definir una \u00fanica QAction, definint l'acci\u00f3 activada i despr\u00e9s afegir aquesta acci\u00f3 tant al men\u00fa com a la barra d'eines. Cada QAction t\u00e9 noms, missatges d'estat, icones i senyals als quals us podeu subscriure. Al codi seg\u00fcent podeu veure aquesta primera QAction a una barra de ferramentes.","title":"QAction"},{"location":"unitats/pyside6/pyside6-menu-actions/#exemple","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sys from PySide6.QtWidgets import ( QMainWindow , QApplication , QLabel , QToolBar ) from PySide6.QtGui import QAction from PySide6.QtCore import Qt class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My Awesome App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) self . addToolBar ( toolbar ) button_action = QAction ( \"Your button\" , self ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) toolbar . addAction ( button_action ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Exemple"},{"location":"unitats/pyside6/pyside6-menu-actions/#barra-destat-status-bar","text":"En el seg\u00fcent exemple creem una barra d'estat i l'afegim a la finestra principal. En passar el ratol\u00ed per damunt el bot\u00f3 de la barra d'estat, es mostra el text definit a la barra d'estats.","title":"Barra d'estat (status bar)"},{"location":"unitats/pyside6/pyside6-menu-actions/#exemple_1","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import sys import os from PySide6.QtWidgets import ( QMainWindow , QApplication , QLabel , QToolBar , QStatusBar ) from PySide6.QtGui import QAction , QIcon from PySide6.QtCore import Qt , QSize class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My Awesome App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) self . setStatusBar ( QStatusBar ( self )) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Podem configurar l'action per a transformar el bot\u00f3 en un polsador. A m\u00e9s, tamb\u00e9 podem afegir una icona i configurar la posici\u00f3 del text que acompanya a aquesta icona segons els valors de la taula seg\u00fcents: Flag Comportament Qt.ToolButtonIconOnly Icona sola, sense text Qt.ToolButtonTextOnly Text sol, sense icona Qt.ToolButtonTextBesideIcon Icona i text, amb el text al costat de la icona Qt.ToolButtonTextUnderIcon Icona i text, amb el text baix de la icona Qt.ToolButtonFollowStyle Seguir l'estil de la configuraci\u00f3 de l'escriptori El valor predeterminat \u00e9s Qt.ToolButtonFollowStyle, el que significa que la vostra aplicaci\u00f3 seguir\u00e0 per defecte la configuraci\u00f3 est\u00e0ndard/global per a l'escriptori on s'executa l'aplicaci\u00f3. Aix\u00f2 es recomana generalment perqu\u00e8 la vostra aplicaci\u00f3 s'integre millor i es senta el m\u00e9s nativa possible. Finalment, afegirem un segon bot\u00f3 i un checkbox a la barra de ferramentes. Podeu posar qualsevol component. Podeu accedir a icones publicades baix CC al seg\u00fcent enlla\u00e7","title":"Exemple"},{"location":"unitats/pyside6/pyside6-menu-actions/#menus","text":"Els men\u00fas s\u00f3n un altre component est\u00e0ndard de les interf\u00edcies d'usuari. Normalment es troben a la part superior de la finestra o a la part superior d'una pantalla a macOS. Permeten l'acc\u00e9s a totes les funcions est\u00e0ndard de l'aplicaci\u00f3. Hi ha uns quants men\u00fas est\u00e0ndard, per exemple Fitxer, Edita, Ajuda. Els men\u00fas es poden anidar per crear arbres jer\u00e0rquics de funcions i sovint admeten i mostren dreceres de teclat per accedir r\u00e0pidament a les seves funcions. Per crear un men\u00fa, creem una barra de men\u00fas que anomenem .menuBar() a QMainWindow. Afegim un men\u00fa a la nostra barra de men\u00fas cridant a .addMenu() , passant el nom del men\u00fa. En este cas l'hem anomenat \"&Fitxer\". El ampersand defineix una tecla r\u00e0pida per mostrar aquest men\u00fa en pr\u00e9mer Alt. Aix\u00f2 no ser\u00e0 visible a macOS. Tingueu en compte que no estem definint una drecera de teclat. Ac\u00ed \u00e9s on entra en joc el poder de les accions. Podem reutilitzar el QAction ja existent per afegir la mateixa funci\u00f3 al men\u00fa. Per afegir una acci\u00f3, cridem a .addAction() passant en una de les nostres accions definides. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Feu clic a l'element del men\u00fa i notareu que es pot alternar com un polsador: hereta les caracter\u00edstiques de QAction. En este segon exemple, afegim algunes coses m\u00e9s al men\u00fa. Afegirem un separador al men\u00fa, que apareixer\u00e0 com una l\u00ednia horitzontal al men\u00fa, i despr\u00e9s afegirem la segona QAction que hem creat. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_menu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Tamb\u00e9 podeu fer servir un ampersand per afegir tecles d'acceleraci\u00f3 al men\u00fa per permetre que una sola tecla s'utilitzi per anar a un element del men\u00fa quan estiga obert . De nou, aix\u00f2 no funciona a macOS. Per afegir un submen\u00fa, nom\u00e9s cal que creeu un nou men\u00fa cridant a addMenu() al men\u00fa principal. A continuaci\u00f3, podeu afegir accions amb normalitat. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) label . setAlignment ( Qt . AlignCenter ) self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_menu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Men\u00fas"},{"location":"unitats/pyside6/pyside6-menu-actions/#dreceres-de-teclat","text":"Finalment afegirem una drecera de teclat a QAction. Definim una drecera de teclat passant setKeySequence() i passant la seq\u00fc\u00e8ncia de tecles. Qualsevol seq\u00fc\u00e8ncia de tecles definida apareixer\u00e0 al men\u00fa. Tingueu en compte que la drecera de teclat est\u00e0 associada amb el QAction i seguir\u00e0 funcionant tant si el QAction s'afegeix o no a un men\u00fa o a una barra d'eines. Les dreceres de teclat es poden definir de diverses maneres, ja sigui passant com a text, utilitzant noms de tecles o utilitzant les seq\u00fc\u00e8ncies de tecles definides. Utilitzeu aquest \u00faltim sempre que pugueu per garantir el compliment dels est\u00e0ndards del sistema operatiu.","title":"Dreceres de teclat"},{"location":"unitats/pyside6/pyside6-menu-actions/#exemple_2","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import sys import os from PySide6.QtCore import QSize , Qt from PySide6.QtGui import QAction , QIcon , QKeySequence from PySide6.QtWidgets import ( QApplication , QCheckBox , QLabel , QMainWindow , QStatusBar , QToolBar , ) class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) label = QLabel ( \"Hello!\" ) # The `Qt` namespace has a lot of attributes to customize # widgets. See: http://doc.qt.io/qt-5/qt.html label . setAlignment ( Qt . AlignCenter ) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self . setCentralWidget ( label ) toolbar = QToolBar ( \"My main toolbar\" ) toolbar . setIconSize ( QSize ( 16 , 16 )) self . addToolBar ( toolbar ) icon_path = os . path . join ( os . path . dirname ( __file__ ), \"img/animal-penguin.png\" ) button_action = QAction ( QIcon ( icon_path ), \"&Your button\" , self ) button_action . setStatusTip ( \"This is your button\" ) button_action . triggered . connect ( self . onMyToolBarButtonClick ) button_action . setCheckable ( True ) # You can enter keyboard shortcuts using key names (e.g. Ctrl+p) # Qt.namespace identifiers (e.g. Qt.CTRL + Qt.Key_P) # or system agnostic identifiers (e.g. QKeySequence.Print) button_action . setShortcut ( QKeySequence ( \"Ctrl+p\" )) toolbar . addAction ( button_action ) toolbar . addSeparator () button_action2 = QAction ( QIcon ( icon_path ), \"Your &button2\" , self ) button_action2 . setStatusTip ( \"This is your button2\" ) button_action2 . triggered . connect ( self . onMyToolBarButtonClick ) button_action2 . setCheckable ( True ) toolbar . addAction ( button_action2 ) toolbar . addWidget ( QLabel ( \"Hello\" )) toolbar . addWidget ( QCheckBox ()) self . setStatusBar ( QStatusBar ( self )) menu = self . menuBar () file_menu = menu . addMenu ( \"&File\" ) file_menu . addAction ( button_action ) file_menu . addSeparator () file_submenu = file_menu . addMenu ( \"Submenu\" ) file_submenu . addAction ( button_action2 ) def onMyToolBarButtonClick ( self , s ): print ( \"click\" , s ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Exemple"},{"location":"unitats/pyside6/pyside6-practica-calculadora/","text":"Pr\u00e0ctica UD2 - Calculadora Fes una calculadora gr\u00e0fica. No ha de tindre el comportament t\u00edpic de les calculadores, on s'introdueix un primer operand, s'introdueix l'operaci\u00f3, buidant-se la pantalla en aquest moment, i despr\u00e9s el segon operand i finalment el = o una nova operaci\u00f3. En la nostra calculadora apareixer\u00e0 a la pantalla una expressi\u00f3 matem\u00e0tica a l'estil de (4 + 3) * 2^3 . Per a calcula el resultat utilitzarem la funci\u00f3 eval. Ampliaci\u00f3 En este apartat hem d'incloure un men\u00fa a la calculadora. Al final d'ell contindr\u00e0 l'opci\u00f3 per tancar l'aplicaci\u00f3. Anteriorment contindr\u00e0 un submen\u00fas de mode , on podrem canviar entre calculadora cient\u00edfica i calculadora normal, i una opci\u00f3 amb un checkbox perqu\u00e8 vaja guardant les operacions a fitxer de text. Tamb\u00e9 afegirem la funcionalitat d'utilitzar la calculadora per teclat, i no solament amb ratol\u00b7l\u00ed. En tot moment, a la barra d'estat ha de indicar el mode de la calculadora (cient\u00edfica o normal), si est\u00e0 guardant els resultats a arxiu i les dreceres de teclat en cas de passar el ratol\u00ed per damunt.","title":"Pr\u00e0ctica 2"},{"location":"unitats/pyside6/pyside6-practica-calculadora/#practica-ud2-calculadora","text":"Fes una calculadora gr\u00e0fica. No ha de tindre el comportament t\u00edpic de les calculadores, on s'introdueix un primer operand, s'introdueix l'operaci\u00f3, buidant-se la pantalla en aquest moment, i despr\u00e9s el segon operand i finalment el = o una nova operaci\u00f3. En la nostra calculadora apareixer\u00e0 a la pantalla una expressi\u00f3 matem\u00e0tica a l'estil de (4 + 3) * 2^3 . Per a calcula el resultat utilitzarem la funci\u00f3 eval.","title":"Pr\u00e0ctica UD2 - Calculadora"},{"location":"unitats/pyside6/pyside6-practica-calculadora/#ampliacio","text":"En este apartat hem d'incloure un men\u00fa a la calculadora. Al final d'ell contindr\u00e0 l'opci\u00f3 per tancar l'aplicaci\u00f3. Anteriorment contindr\u00e0 un submen\u00fas de mode , on podrem canviar entre calculadora cient\u00edfica i calculadora normal, i una opci\u00f3 amb un checkbox perqu\u00e8 vaja guardant les operacions a fitxer de text. Tamb\u00e9 afegirem la funcionalitat d'utilitzar la calculadora per teclat, i no solament amb ratol\u00b7l\u00ed. En tot moment, a la barra d'estat ha de indicar el mode de la calculadora (cient\u00edfica o normal), si est\u00e0 guardant els resultats a arxiu i les dreceres de teclat en cas de passar el ratol\u00ed per damunt.","title":"Ampliaci\u00f3"},{"location":"unitats/pyside6/pyside6-signals-slots/","text":"Senyals i ranures (signal & slots) En l\u2019anterior aplicaci\u00f3 hem incl\u00f2s un bot\u00f3, per\u00f2 que no executa ninguna acci\u00f3 al fer clic sobre ell. Necessitem connectar les accions a alguna funcionalitat. En Qt, a\u00e7\u00f2 s\u2019aconseguix gr\u00e0cies a les senyals i les ranures. Una senyal \u00e9s una notificaci\u00f3 emesa pels components quan es produeix un esdeveniment. Una ranura \u00e9s el nom que Qt dona als rebedors de senyals. En Python, qualsevol funci\u00f3 pot ser una ranura, simplement connectant-li una senyal. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton from PySide6.QtCore import QSize class MainWindow ( QMainWindow ): def __init__ ( self ): QMainWindow . __init__ ( self ) self . setFixedSize ( QSize ( 300 , 300 )) self . setWindowTitle ( \"Exemple signals-slots 1\" ) pybutton = QPushButton ( 'Clic' , self ) #Connectem la senyal clicked a la ranura button_pressed pybutton . clicked . connect ( self . button_pressed ) pybutton . resize ( 100 , 100 ) pybutton . move ( 100 , 100 ) def button_pressed ( self ): ''' S'executa\u00e0 al rebre la notificaci\u00f3 de que s'ha apretat el bot\u00f3: - Observeu que la consola imprimir\u00e0 \"Clic rebut!\" al fer clic al bot\u00f3 ''' print ( 'Clic rebut!' ) if __name__ == \"__main__\" : app = QApplication ([]) mainWin = MainWindow () mainWin . show () app . exec () En l'anterior codi, a m\u00e9s de connectar la senyal a l'slot, hem utilitzat les funcions resize i move per a assignar el tamany i situar un component. Consulta la documentaci\u00f3 per obtindre m\u00e9s informaci\u00f3 sobre les senyals de QPushButton . Activitat 4 (entregable) Fes una aplicaci\u00f3 amb tres botons. Inicialment, l'aplicaci\u00f3 ocupar\u00e0 el tamany normalitzat i els botons estaran centrats, tant verticalment com horitzontalment en tot moment: - Inicialment l'aplicaci\u00f3 es mostrar\u00e0 centrada sobre la pantalla amb el tamany normalitzat. - Al fer clic al bot\u00f3 de l'esquerra Maximitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00e0xim definit. - Al fer clic al bot\u00f3 de la dreta Minimitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00ednim definit. - Al fer clic al bot\u00f3 central Normalitza , l'aplicaci\u00f3 passar\u00e0 a ocupar de nou el tamany normalitzat. - En cada cas, els botons es deshabilitzaran segons corresponga. \u00c9s a dir, en tamany normalitzat, el bot\u00f3 corresponent a normalitzar el tamany estar\u00e0 deshabilitat i la restat habilitats. Per a la resta de tamanys, aplicarem el mateix criteri. - El tamanys normal, m\u00e0xim i m\u00ednim de finestra, aix\u00ed com els tamanys de bot\u00f3 estaran definits a un arxiu config.py - El tamany m\u00ednim mai podr\u00e0 ser inferior a la suma dels tamanys de bot\u00f3. - El title de l'aplicaci\u00f3 mostrar\u00e0 en cada moment en quin estat es troba Normalitzat, Maximitzat o Minimitzat Encadenaments de senyals Fixa't en l'exemple seg\u00fcent: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press Me!\" ) button . setCheckable ( True ) button . clicked . connect ( self . the_button_was_clicked ) button . clicked . connect ( self . the_button_was_toggled ) self . windowTitleChanged . connect ( self . the_window_title_changed ) # Set the central widget of the Window. self . setCentralWidget ( button ) def the_button_was_clicked ( self ): if self . windowTitle () == \"La meua aplicaci\u00f3\" : self . setWindowTitle ( \"My App\" ) else : self . setWindowTitle ( \"La meua aplicaci\u00f3\" ) def the_button_was_toggled ( self ): print ( \"Clic rebut!\" ) def the_window_title_changed ( self , window_title ): print ( \"Window title changed: %s \" % window_title ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Treballant amb senyals i ranures hem de tindre en compte: - Un \u00fanic senyal pot estar connectat a diverses ranures -> Clic desencadena l'execuci\u00f3 de the_button_was_toggled i the_button_was_clicked . - Les ranures poden rebre arguments -> La ranura the_window_title_changed rep window_title com a argument. - Un \u00fanic esdeveniments pot desencadenar l'emissi\u00f3 de diverses senyals connectades entre elles a trav\u00e9s d'una ranura -> Al fer clic es llan\u00e7a l'execuci\u00f3 de the_button_was_clicked , que a la vegada desencadena l'esdeveniment windowTitleChanged . Connectem components entre si No sempre necessitem definir una funci\u00f3 per gestionar un esdeveniment, podem connectar components entre si per fer-ho: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QLabel , QLineEdit , QVBoxLayout , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) container = QWidget () container . setFixedSize ( 240 , 100 ) self . label = QLabel ( container ) self . label . setFixedSize ( 200 , 20 ) self . label . move ( 20 , 20 ) self . input = QLineEdit ( container ) self . input . setFixedSize ( 200 , 20 ) self . input . move ( 20 , 60 ) self . input . textChanged . connect ( self . label . setText ) self . setCentralWidget ( container ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Quan canviem el text del LineEdit , el senyal textChanged envia el text a la ranura a la qual est\u00e0 connectada, en aquest cas \u00e9s la funci\u00f3 setText del Label , canviant aix\u00ed el seu text. Senyals definits per l'usuari Fins ara hem utilitzat els senyals predefinits pels components Qt. Definirem ara els nostres propis senyals. Aix\u00f2 ens ajudar\u00e0 a desacoblar (independitzar, fer que no depenguen unes de altres) les diferents part del programa. A m\u00e9s, ens permetr\u00e0 fer la nostra aplicaci\u00f3 responsiva , en compte de tindre un gran m\u00e8tode update , podem partir el treball entre m\u00faltiples ranures i llan\u00e7ar-les amb una sola senyal. Utilitzarem la classe Signal amb els tipus que ens interesse: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys from PySide6.QtCore import Qt , Signal from PySide6.QtWidgets import QApplication , QMainWindow class MainWindow ( QMainWindow ): message = Signal ( str ) value = Signal ( int , str , int ) another = Signal ( list ) onemore = Signal ( dict ) anything = Signal ( object ) def __init__ ( self ): super () . __init__ () self . message . connect ( self . custom_slot ) self . value . connect ( self . custom_slot ) self . another . connect ( self . custom_slot ) self . onemore . connect ( self . custom_slot ) self . anything . connect ( self . custom_slot ) self . message . emit ( \"my message\" ) self . value . emit ( 23 , \"abc\" , 1 ) self . another . emit ([ 1 , 2 , 3 , 4 , 5 ]) self . onemore . emit ({ \"a\" : 2 , \"b\" : 7 }) self . anything . emit ( 1223 ) def custom_slot ( self , a ): print ( a ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Com podeu observar, utilitzem el m\u00e8tode emit per a llan\u00e7ar el senyal, que \u00e9s capa\u00e7 de transmetre informaci\u00f3 de qualsevol tipus, per\u00f2 no \u00e9s una bona idea que les ranures reben qualsevol tipus, ja que s'hauria de gestionar a la funci\u00f3, cosa que la complicaria molt. Pots crear senyals en qualsevol subclasse de QObject , incl\u00f2s components, finestres i dialegs. Modifiquem la informaci\u00f3 emesa pels senyals Ja hem vist que els senyals poden emetre informaci\u00f3 a les ranures. Per\u00f2 els senyals predefinits, sols envien dades que s'ha definit que envien en el seu disseny. Per exemple, QPushButton.clicked sols envia el valor de checked despr\u00e9s de produir-se l'esdeveniment. Per a botons no seleccionable, setCheckable(False) , sempre enviar\u00e0 el valor False . Per solucionar este problema podem interceptar el senyal i modificar les dades: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () btn = QPushButton ( \"Press me\" ) btn . setCheckable ( True ) btn . clicked . connect ( lambda checked : self . button_clicked ( checked , btn )) self . setCentralWidget ( btn ) def button_clicked ( self , checked , btn ): print ( btn , checked ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () En aquest cas, el senyal clicked emetr\u00e0 l'estat de checked . La funci\u00f3 lambda intercepta el senyal i afegeix la informaci\u00f3 de l'objecte btn . Activitat 5 Fes una aplicaci\u00f3 que tinga un bot\u00f3. Al fer clic sobre ell, s'executar\u00e0 una funci\u00f3 que rebr\u00e0 l'estat del bot\u00f3. A m\u00e9s, emetr\u00e0 un nou senyal connectat a una altra funci\u00f3, que rebr\u00e0 l'estat del senyal i un n\u00famero aleatori. Al rebre la nova funci\u00f3 el senyal, imprimir\u00e0 per pantalla els valors del l'estat del bot\u00f3 i el n\u00famero aleatori. Esdeveniments Cada interacci\u00f3 que l'usuari t\u00e9 amb una aplicaci\u00f3 Qt \u00e9s un esdeveniment. Hi ha molts tipus d'esdeveniments. Cada esdeveniment \u00e9s un objecte que empaqueta informaci\u00f3 sobre la interacci\u00f3 que l'ha produ\u00eft. Els esdeveniments es passen a controladors d'esdeveniments ( event handler ) espec\u00edfics del component on s'ha produ\u00eft la interacci\u00f3. Podem definir gestors d'esdeveniments personalitzats, modificant la manera com els vostres components responen a aquests esdeveniments. Els controladors d'esdeveniments es defineixen com qualsevol altre m\u00e8tode, per\u00f2 el nom \u00e9s espec\u00edfic per al tipus d'esdeveniment que gestionen. Un dels principals esdeveniments que reben els components \u00e9s el QMouseEvent. Els esdeveniments QMouseEvent es produixen en moure i clicar el ratol\u00ed sobre un component. Els seg\u00fcents gestors d'esdeveniments estan disponibles per gestionar els esdeveniments del ratol\u00ed: Gestor d'esdeveniment Tipus d'esdeveniment mouseMoveEvent Moviment de ratol\u00ed mousePressEvent Bot\u00f3 del ratol\u00ed premut mouseReleaseEvent Bot\u00f3 de ratol\u00ed soltat mouseDoubleClickEvent Doble clic detectat Per exemple, fer clic en un component provocar\u00e0 que s'envie un QMouseEvent al gestor d'esdeveniments .mousePressEvent del component. Aquest controlador pot utilitzar l'objecte d'esdeveniment per recollir informaci\u00f3 sobre qu\u00e8 ha passat, com ara qu\u00e8 va desencadenar l'esdeveniment i on concretament es va produir. Podeu interceptar esdeveniments heretant i anul\u00b7lant el m\u00e8tode del controlador a la classe derivada. Podeu triar filtrar, modificar o ignorar esdeveniments, passant-los al controlador normal de l'esdeveniment cridant a la funci\u00f3 de classe pare amb m\u00e8tode super(). Veiem a\u00e7\u00f2 amb una finestra principal. En cada cas, e rebr\u00e0 l'esdeveniment produ\u00eft. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QTextEdit class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . label = QLabel ( \"Click in this window\" ) self . setCentralWidget ( self . label ) def mouseMoveEvent ( self , e ): self . label . setText ( \"mouseMoveEvent\" ) def mousePressEvent ( self , e ): self . label . setText ( \"mousePressEvent\" ) def mouseReleaseEvent ( self , e ): self . label . setText ( \"mouseReleaseEvent\" ) def mouseDoubleClickEvent ( self , e ): self . label . setText ( \"mouseDoubleClickEvent\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Observeu que els esdeveniments de moviment del ratol\u00ed nom\u00e9s es registren quan teniu el bot\u00f3 premut. Podeu canviar-ho afegint un atribut al widget central i cridant ade la finestra. self.centralWidget().setAttribute(Qt.WA_TransparentForMouseEvents) self.setMouseTracking(False) Tamb\u00e9 podeu notar que els esdeveniments de clic i de doble clic es desencadenen quan es prem el bot\u00f3. Nom\u00e9s l'esdeveniment de soltar es dispara quan es deixa de pr\u00e9mer.","title":"Signals - Slots"},{"location":"unitats/pyside6/pyside6-signals-slots/#senyals-i-ranures-signal-slots","text":"En l\u2019anterior aplicaci\u00f3 hem incl\u00f2s un bot\u00f3, per\u00f2 que no executa ninguna acci\u00f3 al fer clic sobre ell. Necessitem connectar les accions a alguna funcionalitat. En Qt, a\u00e7\u00f2 s\u2019aconseguix gr\u00e0cies a les senyals i les ranures. Una senyal \u00e9s una notificaci\u00f3 emesa pels components quan es produeix un esdeveniment. Una ranura \u00e9s el nom que Qt dona als rebedors de senyals. En Python, qualsevol funci\u00f3 pot ser una ranura, simplement connectant-li una senyal. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton from PySide6.QtCore import QSize class MainWindow ( QMainWindow ): def __init__ ( self ): QMainWindow . __init__ ( self ) self . setFixedSize ( QSize ( 300 , 300 )) self . setWindowTitle ( \"Exemple signals-slots 1\" ) pybutton = QPushButton ( 'Clic' , self ) #Connectem la senyal clicked a la ranura button_pressed pybutton . clicked . connect ( self . button_pressed ) pybutton . resize ( 100 , 100 ) pybutton . move ( 100 , 100 ) def button_pressed ( self ): ''' S'executa\u00e0 al rebre la notificaci\u00f3 de que s'ha apretat el bot\u00f3: - Observeu que la consola imprimir\u00e0 \"Clic rebut!\" al fer clic al bot\u00f3 ''' print ( 'Clic rebut!' ) if __name__ == \"__main__\" : app = QApplication ([]) mainWin = MainWindow () mainWin . show () app . exec () En l'anterior codi, a m\u00e9s de connectar la senyal a l'slot, hem utilitzat les funcions resize i move per a assignar el tamany i situar un component. Consulta la documentaci\u00f3 per obtindre m\u00e9s informaci\u00f3 sobre les senyals de QPushButton .","title":"Senyals i ranures (signal &amp; slots)"},{"location":"unitats/pyside6/pyside6-signals-slots/#activitat-4-entregable","text":"Fes una aplicaci\u00f3 amb tres botons. Inicialment, l'aplicaci\u00f3 ocupar\u00e0 el tamany normalitzat i els botons estaran centrats, tant verticalment com horitzontalment en tot moment: - Inicialment l'aplicaci\u00f3 es mostrar\u00e0 centrada sobre la pantalla amb el tamany normalitzat. - Al fer clic al bot\u00f3 de l'esquerra Maximitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00e0xim definit. - Al fer clic al bot\u00f3 de la dreta Minimitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00ednim definit. - Al fer clic al bot\u00f3 central Normalitza , l'aplicaci\u00f3 passar\u00e0 a ocupar de nou el tamany normalitzat. - En cada cas, els botons es deshabilitzaran segons corresponga. \u00c9s a dir, en tamany normalitzat, el bot\u00f3 corresponent a normalitzar el tamany estar\u00e0 deshabilitat i la restat habilitats. Per a la resta de tamanys, aplicarem el mateix criteri. - El tamanys normal, m\u00e0xim i m\u00ednim de finestra, aix\u00ed com els tamanys de bot\u00f3 estaran definits a un arxiu config.py - El tamany m\u00ednim mai podr\u00e0 ser inferior a la suma dels tamanys de bot\u00f3. - El title de l'aplicaci\u00f3 mostrar\u00e0 en cada moment en quin estat es troba Normalitzat, Maximitzat o Minimitzat","title":"Activitat 4 (entregable)"},{"location":"unitats/pyside6/pyside6-signals-slots/#encadenaments-de-senyals","text":"Fixa't en l'exemple seg\u00fcent: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) button = QPushButton ( \"Press Me!\" ) button . setCheckable ( True ) button . clicked . connect ( self . the_button_was_clicked ) button . clicked . connect ( self . the_button_was_toggled ) self . windowTitleChanged . connect ( self . the_window_title_changed ) # Set the central widget of the Window. self . setCentralWidget ( button ) def the_button_was_clicked ( self ): if self . windowTitle () == \"La meua aplicaci\u00f3\" : self . setWindowTitle ( \"My App\" ) else : self . setWindowTitle ( \"La meua aplicaci\u00f3\" ) def the_button_was_toggled ( self ): print ( \"Clic rebut!\" ) def the_window_title_changed ( self , window_title ): print ( \"Window title changed: %s \" % window_title ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Treballant amb senyals i ranures hem de tindre en compte: - Un \u00fanic senyal pot estar connectat a diverses ranures -> Clic desencadena l'execuci\u00f3 de the_button_was_toggled i the_button_was_clicked . - Les ranures poden rebre arguments -> La ranura the_window_title_changed rep window_title com a argument. - Un \u00fanic esdeveniments pot desencadenar l'emissi\u00f3 de diverses senyals connectades entre elles a trav\u00e9s d'una ranura -> Al fer clic es llan\u00e7a l'execuci\u00f3 de the_button_was_clicked , que a la vegada desencadena l'esdeveniment windowTitleChanged .","title":"Encadenaments de senyals"},{"location":"unitats/pyside6/pyside6-signals-slots/#connectem-components-entre-si","text":"No sempre necessitem definir una funci\u00f3 per gestionar un esdeveniment, podem connectar components entre si per fer-ho: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import sys from PySide6.QtWidgets import QApplication , QMainWindow , QLabel , QLineEdit , QVBoxLayout , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) container = QWidget () container . setFixedSize ( 240 , 100 ) self . label = QLabel ( container ) self . label . setFixedSize ( 200 , 20 ) self . label . move ( 20 , 20 ) self . input = QLineEdit ( container ) self . input . setFixedSize ( 200 , 20 ) self . input . move ( 20 , 60 ) self . input . textChanged . connect ( self . label . setText ) self . setCentralWidget ( container ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Quan canviem el text del LineEdit , el senyal textChanged envia el text a la ranura a la qual est\u00e0 connectada, en aquest cas \u00e9s la funci\u00f3 setText del Label , canviant aix\u00ed el seu text.","title":"Connectem components entre si"},{"location":"unitats/pyside6/pyside6-signals-slots/#senyals-definits-per-lusuari","text":"Fins ara hem utilitzat els senyals predefinits pels components Qt. Definirem ara els nostres propis senyals. Aix\u00f2 ens ajudar\u00e0 a desacoblar (independitzar, fer que no depenguen unes de altres) les diferents part del programa. A m\u00e9s, ens permetr\u00e0 fer la nostra aplicaci\u00f3 responsiva , en compte de tindre un gran m\u00e8tode update , podem partir el treball entre m\u00faltiples ranures i llan\u00e7ar-les amb una sola senyal. Utilitzarem la classe Signal amb els tipus que ens interesse: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys from PySide6.QtCore import Qt , Signal from PySide6.QtWidgets import QApplication , QMainWindow class MainWindow ( QMainWindow ): message = Signal ( str ) value = Signal ( int , str , int ) another = Signal ( list ) onemore = Signal ( dict ) anything = Signal ( object ) def __init__ ( self ): super () . __init__ () self . message . connect ( self . custom_slot ) self . value . connect ( self . custom_slot ) self . another . connect ( self . custom_slot ) self . onemore . connect ( self . custom_slot ) self . anything . connect ( self . custom_slot ) self . message . emit ( \"my message\" ) self . value . emit ( 23 , \"abc\" , 1 ) self . another . emit ([ 1 , 2 , 3 , 4 , 5 ]) self . onemore . emit ({ \"a\" : 2 , \"b\" : 7 }) self . anything . emit ( 1223 ) def custom_slot ( self , a ): print ( a ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Com podeu observar, utilitzem el m\u00e8tode emit per a llan\u00e7ar el senyal, que \u00e9s capa\u00e7 de transmetre informaci\u00f3 de qualsevol tipus, per\u00f2 no \u00e9s una bona idea que les ranures reben qualsevol tipus, ja que s'hauria de gestionar a la funci\u00f3, cosa que la complicaria molt. Pots crear senyals en qualsevol subclasse de QObject , incl\u00f2s components, finestres i dialegs.","title":"Senyals definits per l'usuari"},{"location":"unitats/pyside6/pyside6-signals-slots/#modifiquem-la-informacio-emesa-pels-senyals","text":"Ja hem vist que els senyals poden emetre informaci\u00f3 a les ranures. Per\u00f2 els senyals predefinits, sols envien dades que s'ha definit que envien en el seu disseny. Per exemple, QPushButton.clicked sols envia el valor de checked despr\u00e9s de produir-se l'esdeveniment. Per a botons no seleccionable, setCheckable(False) , sempre enviar\u00e0 el valor False . Per solucionar este problema podem interceptar el senyal i modificar les dades: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QPushButton class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () btn = QPushButton ( \"Press me\" ) btn . setCheckable ( True ) btn . clicked . connect ( lambda checked : self . button_clicked ( checked , btn )) self . setCentralWidget ( btn ) def button_clicked ( self , checked , btn ): print ( btn , checked ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () En aquest cas, el senyal clicked emetr\u00e0 l'estat de checked . La funci\u00f3 lambda intercepta el senyal i afegeix la informaci\u00f3 de l'objecte btn .","title":"Modifiquem la informaci\u00f3 emesa pels senyals"},{"location":"unitats/pyside6/pyside6-signals-slots/#activitat-5","text":"Fes una aplicaci\u00f3 que tinga un bot\u00f3. Al fer clic sobre ell, s'executar\u00e0 una funci\u00f3 que rebr\u00e0 l'estat del bot\u00f3. A m\u00e9s, emetr\u00e0 un nou senyal connectat a una altra funci\u00f3, que rebr\u00e0 l'estat del senyal i un n\u00famero aleatori. Al rebre la nova funci\u00f3 el senyal, imprimir\u00e0 per pantalla els valors del l'estat del bot\u00f3 i el n\u00famero aleatori.","title":"Activitat 5"},{"location":"unitats/pyside6/pyside6-signals-slots/#esdeveniments","text":"Cada interacci\u00f3 que l'usuari t\u00e9 amb una aplicaci\u00f3 Qt \u00e9s un esdeveniment. Hi ha molts tipus d'esdeveniments. Cada esdeveniment \u00e9s un objecte que empaqueta informaci\u00f3 sobre la interacci\u00f3 que l'ha produ\u00eft. Els esdeveniments es passen a controladors d'esdeveniments ( event handler ) espec\u00edfics del component on s'ha produ\u00eft la interacci\u00f3. Podem definir gestors d'esdeveniments personalitzats, modificant la manera com els vostres components responen a aquests esdeveniments. Els controladors d'esdeveniments es defineixen com qualsevol altre m\u00e8tode, per\u00f2 el nom \u00e9s espec\u00edfic per al tipus d'esdeveniment que gestionen. Un dels principals esdeveniments que reben els components \u00e9s el QMouseEvent. Els esdeveniments QMouseEvent es produixen en moure i clicar el ratol\u00ed sobre un component. Els seg\u00fcents gestors d'esdeveniments estan disponibles per gestionar els esdeveniments del ratol\u00ed: Gestor d'esdeveniment Tipus d'esdeveniment mouseMoveEvent Moviment de ratol\u00ed mousePressEvent Bot\u00f3 del ratol\u00ed premut mouseReleaseEvent Bot\u00f3 de ratol\u00ed soltat mouseDoubleClickEvent Doble clic detectat Per exemple, fer clic en un component provocar\u00e0 que s'envie un QMouseEvent al gestor d'esdeveniments .mousePressEvent del component. Aquest controlador pot utilitzar l'objecte d'esdeveniment per recollir informaci\u00f3 sobre qu\u00e8 ha passat, com ara qu\u00e8 va desencadenar l'esdeveniment i on concretament es va produir. Podeu interceptar esdeveniments heretant i anul\u00b7lant el m\u00e8tode del controlador a la classe derivada. Podeu triar filtrar, modificar o ignorar esdeveniments, passant-los al controlador normal de l'esdeveniment cridant a la funci\u00f3 de classe pare amb m\u00e8tode super(). Veiem a\u00e7\u00f2 amb una finestra principal. En cada cas, e rebr\u00e0 l'esdeveniment produ\u00eft. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QTextEdit class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . label = QLabel ( \"Click in this window\" ) self . setCentralWidget ( self . label ) def mouseMoveEvent ( self , e ): self . label . setText ( \"mouseMoveEvent\" ) def mousePressEvent ( self , e ): self . label . setText ( \"mousePressEvent\" ) def mouseReleaseEvent ( self , e ): self . label . setText ( \"mouseReleaseEvent\" ) def mouseDoubleClickEvent ( self , e ): self . label . setText ( \"mouseDoubleClickEvent\" ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Observeu que els esdeveniments de moviment del ratol\u00ed nom\u00e9s es registren quan teniu el bot\u00f3 premut. Podeu canviar-ho afegint un atribut al widget central i cridant ade la finestra. self.centralWidget().setAttribute(Qt.WA_TransparentForMouseEvents) self.setMouseTracking(False) Tamb\u00e9 podeu notar que els esdeveniments de clic i de doble clic es desencadenen quan es prem el bot\u00f3. Nom\u00e9s l'esdeveniment de soltar es dispara quan es deixa de pr\u00e9mer.","title":"Esdeveniments"},{"location":"unitats/pyside6/pyside6-widgets/","text":"Components (Widgets) A Qt (i la majoria de les interf\u00edcies d'usuari) widget \u00e9s el nom donat a un component de la interf\u00edcie d'usuari amb el qual l'usuari pot interactuar. Les interf\u00edcies d'usuari estan formades per diversos widgets o components, disposats dins de la finestra. Qt inclou una gran selecci\u00f3 de widgets disponibles, i fins i tot us permet crear els vostres propis components personalitzats. Una demostraci\u00f3 r\u00e0pida Primer fem una ullada a alguns dels widgets PySide m\u00e9s comuns. El codi seg\u00fcent crea una s\u00e8rie de ginys PySide i els afegeix a un disseny de finestra perqu\u00e8 pugueu veure'ls junts. Text Only 1 Veurem com funcionen els *layouts* a m\u00e9s endavant. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QCheckBox , QComboBox , QDateEdit , QDateTimeEdit , QDial , QDoubleSpinBox , QFontComboBox , QLabel , QLCDNumber , QLineEdit , QMainWindow , QProgressBar , QPushButton , QRadioButton , QSlider , QSpinBox , QTimeEdit , QVBoxLayout , QWidget , ) # Subclass QMainWindow to customize your application's main window class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"Widgets App\" ) layout = QVBoxLayout () widgets = [ QCheckBox , QComboBox , QDateEdit , QDateTimeEdit , QDial , QDoubleSpinBox , QFontComboBox , QLCDNumber , QLabel , QLineEdit , QProgressBar , QPushButton , QRadioButton , QSlider , QSpinBox , QTimeEdit , ] for w in widgets : layout . addWidget ( w ()) widget = QWidget () widget . setLayout ( layout ) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec () Principals Widgets PySide6 t\u00e9 disponible multitud de widgets i cadascun d'ells s'utilitza de forma semblant, amb algunes peculiaritats segons el seu tipus. Veurem ara alguns exemples de cadascun dels principals Widgets: Label Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from PySide6.QtCore import Qt from PySide6.QtGui import QFont , QPixmap from PySide6.QtWidgets import QApplication , QLabel , QMainWindow class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QLabel ( \"Hello\" ) widget . setPixmap ( QPixmap ( \"github/di21-22/docs/resources/code/PySide6/logo_qt.png\" )) widget . setScaledContents ( True ) # font = widget.font() # font.setPointSize(30) # font.setFamily(\"Noto Serif Armenian\") # font.setBold(True) # widget.setFont(font) # widget.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter) self . setCentralWidget ( widget ) app = QApplication ([]) main_window = MainWindow () main_window . show () app . exec () CheckBox Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QCheckBox class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) self . widget = QCheckBox () self . widget . setCheckState ( Qt . Checked ) self . widget . setTristate ( True ) # For tristate: self.widget.setCheckState(Qt.PartiallyChecked) # Or: self.widget.setTriState(True) self . widget . stateChanged . connect ( self . show_state ) self . setCentralWidget ( self . widget ) def show_state ( self , s ): print ( s == Qt . Checked ) print ( s ) self . widget . move ( 0 , 50 ) app = QApplication ([]) window = MainWindow () window . show () app . exec () ComboBox Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from PySide6.QtCore import Qt , QSize from PySide6.QtWidgets import QApplication , QMainWindow , QComboBox , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) self . widget = QWidget () self . combo_box = QComboBox ( self . widget ) self . combo_box . setFixedWidth ( 200 ) self . combo_box . addItems ([ \"One\" , \"Two\" , \"Three\" ]) # The default signal from currentIndexChanged sends the index self . combo_box . currentIndexChanged . connect ( self . index_changed ) # The same signal can send a text string self . combo_box . currentTextChanged . connect ( self . text_changed ) self . setCentralWidget ( self . widget ) def index_changed ( self , i ): # i is an int print ( i ) def text_changed ( self , s ): # s is a str print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec () ListWidget Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QListWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QListWidget () widget . addItems ([ \"One\" , \"Two\" , \"Three\" ]) # In QListWidget there are two separate signals for the item, and the str widget . currentItemChanged . connect ( self . index_changed ) widget . currentTextChanged . connect ( self . text_changed ) self . setCentralWidget ( widget ) def index_changed ( self , i ): # Not an index, i is a QListItem print ( i . text ()) def text_changed ( self , s ): # s is a str print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec () LineEdit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QLineEdit , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () line_edit = QLineEdit ( widget ) line_edit . setMaxLength ( 10 ) line_edit . setPlaceholderText ( \"Enter your text\" ) #widget.setReadOnly(True) # uncomment this to make readonly line_edit . returnPressed . connect ( self . return_pressed ) line_edit . selectionChanged . connect ( self . selection_changed ) line_edit . textChanged . connect ( self . text_changed ) line_edit . textEdited . connect ( self . text_edited ) self . setCentralWidget ( widget ) def return_pressed ( self ): print ( \"Return pressed!\" ) self . centralWidget () . setText ( \"BOOM!\" ) def selection_changed ( self ): print ( \"Selection changed\" ) print ( self . centralWidget () . selectedText ()) def text_changed ( self , s ): print ( \"Text changed...\" ) print ( s ) def text_edited ( self , s ): print ( \"Text edited...\" ) print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec () SpinBox Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QSpinBox class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QSpinBox () # Or: widget = QDoubleSpinBox() widget . setMinimum ( - 10 ) widget . setMaximum ( 3 ) # Or: widget.setRange(-10,3) widget . setPrefix ( \"$\" ) widget . setSuffix ( \"c\" ) widget . setSingleStep ( 3 ) # Or e.g. 0.5 for QDoubleSpinBox widget . valueChanged . connect ( self . value_changed ) widget . textChanged . connect ( self . value_changed_str ) self . setCentralWidget ( widget ) def value_changed ( self , i ): print ( i ) def value_changed_str ( self , s ): print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec () Slider Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QSlider , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () slider = QSlider ( widget ) self . label = QLabel ( \" 0 \" , widget ) self . label . move ( 25 , 0 ) slider . setMinimum ( - 10 ) slider . setMaximum ( 3 ) # Or: widget.setRange(-10,3) slider . setSingleStep ( 1 ) slider . setSliderPosition ( 0 ) slider . valueChanged . connect ( self . value_changed ) slider . sliderMoved . connect ( self . slider_position ) slider . sliderPressed . connect ( self . slider_pressed ) slider . sliderReleased . connect ( self . slider_released ) self . setCentralWidget ( widget ) def value_changed ( self , i ): self . label . setText ( str ( i )) def slider_position ( self , p ): print ( \"position\" , p ) def slider_pressed ( self ): print ( \"Pressed!\" ) def slider_released ( self ): print ( \"Released\" ) app = QApplication ([]) window = MainWindow () window . show () app . exec () Dial Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QDial , QVBoxLayout , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () layout = QVBoxLayout ( widget ) dial = QDial () dial . setRange ( 0 , 60 ) dial . setSingleStep ( 1 ) layout . addWidget ( dial ) self . label = QLabel ( f 'Value: { dial . sliderPosition () } ' ) layout . addWidget ( self . label ) dial . valueChanged . connect ( self . value_changed ) dial . sliderMoved . connect ( self . slider_position ) dial . sliderPressed . connect ( self . slider_pressed ) dial . sliderReleased . connect ( self . slider_released ) self . setCentralWidget ( widget ) def value_changed ( self , i ): text = f 'Value: { i } ' self . label . setText ( text ) def slider_position ( self , p ): print ( \"position\" , p ) def slider_pressed ( self ): print ( \"Pressed!\" ) def slider_released ( self ): print ( \"Released\" ) app = QApplication ([]) window = MainWindow () window . show () app . exec () Activitat 6 Fes una aplicaci\u00f3 amb un dial, un slider i un label. Tant l'slider com el dial tindran valors entre 0 i 10. Quan es moga l'slider, el dial es mour\u00e0 agafant el mateix valor i el label mostrar\u00e0 el seu valor. Quan es mou el dial, el comportament ser\u00e0 el mateix.","title":"Widgets"},{"location":"unitats/pyside6/pyside6-widgets/#components-widgets","text":"A Qt (i la majoria de les interf\u00edcies d'usuari) widget \u00e9s el nom donat a un component de la interf\u00edcie d'usuari amb el qual l'usuari pot interactuar. Les interf\u00edcies d'usuari estan formades per diversos widgets o components, disposats dins de la finestra. Qt inclou una gran selecci\u00f3 de widgets disponibles, i fins i tot us permet crear els vostres propis components personalitzats.","title":"Components (Widgets)"},{"location":"unitats/pyside6/pyside6-widgets/#una-demostracio-rapida","text":"Primer fem una ullada a alguns dels widgets PySide m\u00e9s comuns. El codi seg\u00fcent crea una s\u00e8rie de ginys PySide i els afegeix a un disseny de finestra perqu\u00e8 pugueu veure'ls junts. Text Only 1 Veurem com funcionen els *layouts* a m\u00e9s endavant. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication , QCheckBox , QComboBox , QDateEdit , QDateTimeEdit , QDial , QDoubleSpinBox , QFontComboBox , QLabel , QLCDNumber , QLineEdit , QMainWindow , QProgressBar , QPushButton , QRadioButton , QSlider , QSpinBox , QTimeEdit , QVBoxLayout , QWidget , ) # Subclass QMainWindow to customize your application's main window class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"Widgets App\" ) layout = QVBoxLayout () widgets = [ QCheckBox , QComboBox , QDateEdit , QDateTimeEdit , QDial , QDoubleSpinBox , QFontComboBox , QLCDNumber , QLabel , QLineEdit , QProgressBar , QPushButton , QRadioButton , QSlider , QSpinBox , QTimeEdit , ] for w in widgets : layout . addWidget ( w ()) widget = QWidget () widget . setLayout ( layout ) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self . setCentralWidget ( widget ) app = QApplication ( sys . argv ) window = MainWindow () window . show () app . exec ()","title":"Una demostraci\u00f3 r\u00e0pida"},{"location":"unitats/pyside6/pyside6-widgets/#principals-widgets","text":"PySide6 t\u00e9 disponible multitud de widgets i cadascun d'ells s'utilitza de forma semblant, amb algunes peculiaritats segons el seu tipus. Veurem ara alguns exemples de cadascun dels principals Widgets:","title":"Principals Widgets"},{"location":"unitats/pyside6/pyside6-widgets/#label","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from PySide6.QtCore import Qt from PySide6.QtGui import QFont , QPixmap from PySide6.QtWidgets import QApplication , QLabel , QMainWindow class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QLabel ( \"Hello\" ) widget . setPixmap ( QPixmap ( \"github/di21-22/docs/resources/code/PySide6/logo_qt.png\" )) widget . setScaledContents ( True ) # font = widget.font() # font.setPointSize(30) # font.setFamily(\"Noto Serif Armenian\") # font.setBold(True) # widget.setFont(font) # widget.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter) self . setCentralWidget ( widget ) app = QApplication ([]) main_window = MainWindow () main_window . show () app . exec ()","title":"Label"},{"location":"unitats/pyside6/pyside6-widgets/#checkbox","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QCheckBox class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) self . widget = QCheckBox () self . widget . setCheckState ( Qt . Checked ) self . widget . setTristate ( True ) # For tristate: self.widget.setCheckState(Qt.PartiallyChecked) # Or: self.widget.setTriState(True) self . widget . stateChanged . connect ( self . show_state ) self . setCentralWidget ( self . widget ) def show_state ( self , s ): print ( s == Qt . Checked ) print ( s ) self . widget . move ( 0 , 50 ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"CheckBox"},{"location":"unitats/pyside6/pyside6-widgets/#combobox","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from PySide6.QtCore import Qt , QSize from PySide6.QtWidgets import QApplication , QMainWindow , QComboBox , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) self . widget = QWidget () self . combo_box = QComboBox ( self . widget ) self . combo_box . setFixedWidth ( 200 ) self . combo_box . addItems ([ \"One\" , \"Two\" , \"Three\" ]) # The default signal from currentIndexChanged sends the index self . combo_box . currentIndexChanged . connect ( self . index_changed ) # The same signal can send a text string self . combo_box . currentTextChanged . connect ( self . text_changed ) self . setCentralWidget ( self . widget ) def index_changed ( self , i ): # i is an int print ( i ) def text_changed ( self , s ): # s is a str print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"ComboBox"},{"location":"unitats/pyside6/pyside6-widgets/#listwidget","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QListWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QListWidget () widget . addItems ([ \"One\" , \"Two\" , \"Three\" ]) # In QListWidget there are two separate signals for the item, and the str widget . currentItemChanged . connect ( self . index_changed ) widget . currentTextChanged . connect ( self . text_changed ) self . setCentralWidget ( widget ) def index_changed ( self , i ): # Not an index, i is a QListItem print ( i . text ()) def text_changed ( self , s ): # s is a str print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"ListWidget"},{"location":"unitats/pyside6/pyside6-widgets/#lineedit","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QLineEdit , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super ( MainWindow , self ) . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () line_edit = QLineEdit ( widget ) line_edit . setMaxLength ( 10 ) line_edit . setPlaceholderText ( \"Enter your text\" ) #widget.setReadOnly(True) # uncomment this to make readonly line_edit . returnPressed . connect ( self . return_pressed ) line_edit . selectionChanged . connect ( self . selection_changed ) line_edit . textChanged . connect ( self . text_changed ) line_edit . textEdited . connect ( self . text_edited ) self . setCentralWidget ( widget ) def return_pressed ( self ): print ( \"Return pressed!\" ) self . centralWidget () . setText ( \"BOOM!\" ) def selection_changed ( self ): print ( \"Selection changed\" ) print ( self . centralWidget () . selectedText ()) def text_changed ( self , s ): print ( \"Text changed...\" ) print ( s ) def text_edited ( self , s ): print ( \"Text edited...\" ) print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"LineEdit"},{"location":"unitats/pyside6/pyside6-widgets/#spinbox","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication , QMainWindow , QSpinBox class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QSpinBox () # Or: widget = QDoubleSpinBox() widget . setMinimum ( - 10 ) widget . setMaximum ( 3 ) # Or: widget.setRange(-10,3) widget . setPrefix ( \"$\" ) widget . setSuffix ( \"c\" ) widget . setSingleStep ( 3 ) # Or e.g. 0.5 for QDoubleSpinBox widget . valueChanged . connect ( self . value_changed ) widget . textChanged . connect ( self . value_changed_str ) self . setCentralWidget ( widget ) def value_changed ( self , i ): print ( i ) def value_changed_str ( self , s ): print ( s ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"SpinBox"},{"location":"unitats/pyside6/pyside6-widgets/#slider","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QSlider , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () slider = QSlider ( widget ) self . label = QLabel ( \" 0 \" , widget ) self . label . move ( 25 , 0 ) slider . setMinimum ( - 10 ) slider . setMaximum ( 3 ) # Or: widget.setRange(-10,3) slider . setSingleStep ( 1 ) slider . setSliderPosition ( 0 ) slider . valueChanged . connect ( self . value_changed ) slider . sliderMoved . connect ( self . slider_position ) slider . sliderPressed . connect ( self . slider_pressed ) slider . sliderReleased . connect ( self . slider_released ) self . setCentralWidget ( widget ) def value_changed ( self , i ): self . label . setText ( str ( i )) def slider_position ( self , p ): print ( \"position\" , p ) def slider_pressed ( self ): print ( \"Pressed!\" ) def slider_released ( self ): print ( \"Released\" ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"Slider"},{"location":"unitats/pyside6/pyside6-widgets/#dial","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from PySide6.QtWidgets import QApplication , QLabel , QMainWindow , QDial , QVBoxLayout , QWidget class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () self . setWindowTitle ( \"My App\" ) widget = QWidget () layout = QVBoxLayout ( widget ) dial = QDial () dial . setRange ( 0 , 60 ) dial . setSingleStep ( 1 ) layout . addWidget ( dial ) self . label = QLabel ( f 'Value: { dial . sliderPosition () } ' ) layout . addWidget ( self . label ) dial . valueChanged . connect ( self . value_changed ) dial . sliderMoved . connect ( self . slider_position ) dial . sliderPressed . connect ( self . slider_pressed ) dial . sliderReleased . connect ( self . slider_released ) self . setCentralWidget ( widget ) def value_changed ( self , i ): text = f 'Value: { i } ' self . label . setText ( text ) def slider_position ( self , p ): print ( \"position\" , p ) def slider_pressed ( self ): print ( \"Pressed!\" ) def slider_released ( self ): print ( \"Released\" ) app = QApplication ([]) window = MainWindow () window . show () app . exec ()","title":"Dial"},{"location":"unitats/pyside6/pyside6-widgets/#activitat-6","text":"Fes una aplicaci\u00f3 amb un dial, un slider i un label. Tant l'slider com el dial tindran valors entre 0 i 10. Quan es moga l'slider, el dial es mour\u00e0 agafant el mateix valor i el label mostrar\u00e0 el seu valor. Quan es mou el dial, el comportament ser\u00e0 el mateix.","title":"Activitat 6"}]}