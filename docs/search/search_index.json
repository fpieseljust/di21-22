{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts!! Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 21/22. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Home"},{"location":"#benvinguts","text":"Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 21/22. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Benvinguts!!"},{"location":"about/","text":"Desenvolupament d'interf\u00e9cies RD: 450/2010 Curr\u00edculum CV: Ordre 58/2012 IES Jaume II \"El Just\" - Tavernes de la Valldigna Curs 2021-2022 Professor: Ferran Cunyat","title":"About"},{"location":"about/#desenvolupament-dinterfecies","text":"RD: 450/2010 Curr\u00edculum CV: Ordre 58/2012","title":"Desenvolupament d'interf\u00e9cies"},{"location":"about/#ies-jaume-ii-el-just-tavernes-de-la-valldigna","text":"","title":"IES Jaume II \"El Just\" - Tavernes de la Valldigna"},{"location":"about/#curs-2021-2022","text":"Professor: Ferran Cunyat","title":"Curs 2021-2022"},{"location":"unitats/pyside6/pyside6-intro/","text":"Qt i PySide PySide \u00e9s la uni\u00f3 de Python amb el conjunt d'eines per a desenvolupament d'interf\u00edcies gr\u00e0fiques d'usuari multiplataforma Qt, desenvolupat per The Qt Company , com a part del projecte Qt for Python . \u00c9s una de les alternatives al paquet de biblioteca est\u00e0ndard Tkinter. Igual que Qt, PySide \u00e9s programari lliure. PySide \u00e9s compatible amb Linux/X11, macOS i Microsoft Windows. Tot i que hi ha documentaci\u00f3 espec\u00edfica de PySide disponible, tamb\u00e9 podem utilitzar la documentaci\u00f3 de Qt , tenint en compte que s'haur\u00e0 de traduir la sintaxi d'objectes i m\u00e8todes per adaptar-ho a Python. Versions de PySide Hi ha hagut tres versions principals de PySide: PySide \u00e9s compatible amb Qt 4 PySide2 \u00e9s compatible amb Qt 5 PySide6 \u00e9s compatible amb Qt 6 La versi\u00f3 1 de PySide va ser llan\u00e7ada l'agost de 2009 baix llic\u00e8ncia LGPL per Nokia, aleshores propietaria de Qt, despr\u00e9s de no arribar a un acord amb els desenvolupadors de PyQt, Riverbank Computing, per canviar els seus termes de llic\u00e8ncia per incloure LGPL com a llic\u00e8ncia alternativa. Va donar suport a Qt 4 sota els sistemes operatius Linux/X11, Mac OS X, Microsoft Windows, Maemo i MeeGo, mentre que la comunitat PySide va afegir suport per a Android. Christian Tismer va iniciar PySide2 per portar PySide de Qt 4 a Qt 5 el 2015. Aleshores, el projecte es va incorporar al projecte Qt.Va ser llan\u00e7at el desembre de 2018. PySide6 es va llan\u00e7ar el desembre de 2020. Va afegir suport per a Qt 6 i va eliminar el suport per a totes les versions de Python anteriors a la 3.6. El projecte va comen\u00e7ar utilitzant Boost.Python de les biblioteques de Boost C++ per a enlla\u00e7ar el codi Python amb les crides C++, llenguatge sobre el que est\u00e0 contru\u00eft Qt. M\u00e9s tard va crear el seu propi generador d'enlla\u00e7 anomenat Shiboken, per reduir la mida dels executables i l'\u00fas de mem\u00f2ria. Nosaltres farem \u00fas de PySide6 durant el present curs. Instal\u00b7laci\u00f3 de PySide6 Sempre que desenvolupem, hauriem de fer-ho en un entorn virtual. Recordeu que per crear-lo i activar-lo, utilitzem: python3 -m venv .venv source .venv/bin/activate #Per a Linux i macOS env\\Scripts\\activate.bat #Per a Windows Per a instal\u00b7lar PySide6 utilitzem pip : pip install pyside6 Comprovem la Instal\u00b7laci\u00f3 Una vegada instal\u00b7lat i amb l'entorn virtual activat, podem executar el seg\u00fcent codi per comprovar que tot funciona. import PySide6.QtCore # Prints PySide6 version print(PySide6.__version__) # Prints the Qt version used to compile PySide6 print(PySide6.QtCore.__version__) Primera aplicaci\u00f3 amb PySide6 - Hola m\u00f3n! Exemple: Hola m\u00f3n! amb PySide6 from PySide6 import QtWidgets, QtCore # Sols si necessitem arguments importem sys import sys if __name__ == \"__main__\": # Necessitem una inst\u00e0ncia (i sols una) de QApplication per cada aplicaci\u00f3. # Li passem sys.argv per a permetre arguments des de la l\u00ednia de comandaments # Si no anem a passar arguments podem utilitzar QApplication([]) app = QtWidgets.QApplication(sys.argv) # Creem un QLabel amb el text Hola m\u00f3n! i aliniament al centre. label = QtWidgets.QLabel(\"Hola m\u00f3n!\", alignment=QtCore.Qt.AlignCenter) # Redimensionem el QLabel label.resize(800, 600) #Fem visible el label IMPORTANT!!!!! Els components estan ocults per defecte. label.show() # Iniciem el bucle d\u2019esdeveniments. sys.exit(app.exec()) Si rebeu l'error libOpenGL.so.0: cannot open shared object file: No such file or directory , heu d'instal\u00b7lar la llibreria libopengl0 . sudo apt install libopengl0 -y Baixeu el codi d'ac\u00ed Qu\u00e8 \u00e9s una finestra? Cont\u00e9 la interf\u00edcie de l\u2019usuari Cada aplicaci\u00f3 en necessita almenys una, per\u00f2 en pot tindre m\u00e9s L\u2019aplicaci\u00f3, per defecte, acabar\u00e0 en tancar l\u2019\u00faltima d\u2019elles Qu\u00e8 \u00e9s el bucle d\u2019esdeveniments (event loop)? Ja hem vist que cada aplicaci\u00f3 necessita un i sols un objecte QApplication. Aquest objecte gestiona els esdeveniments. Cada una de les interaccions de l\u2019usuari amb la interf\u00edcie, per exemple, un clic de ratol\u00ed sobre un element, genera un esdeveniment. L\u2019esdeveniment es col\u00b7loca a la cola d\u2019esdeveniments per ser gestionat ( event queue ). Al bucle d'esdeveniments ( event loop ), la cua es comprova a cada iteraci\u00f3 i si es troba un esdeveniment en espera, l'esdeveniment i el control es passen al gestor de l\u2019esdeveniment ( event handler ). El gestor d'esdeveniments s'ocupa de l'esdeveniment i despr\u00e9s passa de nou el control al bucle d'esdeveniments per esperar m\u00e9s esdeveniments. Nom\u00e9s hi ha un bucle d'esdeveniments per aplicaci\u00f3. QMainWindow Es tracta d\u2019un component pre-definit que proporciona moltes funcions est\u00e0ndard de les finestres que fareu servir les vostres aplicacions, com poden ser les barres d'eines, els men\u00fas, la barra d'estat, els components que es poden acoblar, etc. Veurem aquestes funcions avan\u00e7ades m\u00e9s endavant, per\u00f2 de moment anem a fer \u00fas d\u2019ella a la nostra aplicaci\u00f3. Activitat 1 Anem a crear la nostra primera aplicaci\u00f3. Has de definir una classe MainWindow, que herede de QmainWindow. Amb el m\u00e8tode setWindowTitle() posa-li t\u00edtol a l\u2019aplicaci\u00f3 \u00abLa meua aplicaci\u00f3\u00bb. Amb QPushButton(), crea un bot\u00f3 amb el text, \u00abAceptar\u00bb. Afig el bot\u00f3 a la part central de la finestra amb setCentralWidget(\u00abcomponent\u00bb). Recorda mostrar la finestra i iniciar el bucle d\u2019esdeveniments. Activitat 2 Modifica el codi de l\u2019anterior activitat per a que es puga passar per l\u00ednia de comandaments el t\u00edtol i el text del bot\u00f3. python3 activitat2.2.py \"APP\" \"Text\" Assignem tamany a les finestres i els components Amb la funcions .setFixedSize(amplada, altura) assignem una mida fixa al component sobre el que l\u2019apliquem. Amb .setMinimumSize(amplada, altura) i setMaximumSize(amplada, altura) , assignem les mides m\u00e0ximes i m\u00ednimes, de forma que ni redimensionant amb el ratol\u00ed ni amb els botons de maximitzar i minimitzar tindrem la possibilitat d\u2019establir unes dimensions menors o majors de les establides. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self, title=\"Title\", button_text=\"Text\", fixed=False): super().__init__() self.setWindowTitle(title) self.button = QPushButton(button_text) self.setCentralWidget(self.button) #self.setFixedSize(400,600) self.button.setMaximumSize(100,25) self.setMaximumSize(400,400) self.setMinimumSize(200,200) self.button.show() self.show() app = QApplication(sys.argv) window = MainWindow() app.exec() Baixa el codi punxant el seg\u00fcent enlla\u00e7 Activitat 3 (entregable) Basant-nos en el codi de l'activitat 2, anem a fer una gesti\u00f3 m\u00e9s pr\u00e0ctica i real dels par\u00e0metres d'entrada de l'script. Este \u00e9s l'aspecte que tindr\u00e0 l'ajuda de l'execuci\u00f3 de l'script. usage: finestra3_args.py [-h] [-t TITLE] [-b BUTTON_TEXT] [-f] [-s SIZE SIZE] optional arguments: -h, --help show this help message and exit -t TITLE, --title TITLE Title of application -b BUTTON_TEXT, --button-text BUTTON_TEXT Button text -f, --fixed-size Window fixed size -s SIZE SIZE, --size SIZE SIZE Size of windows Per a fer tota aquesta gesti\u00f3, busca una llibreria de python que t'ajude.","title":"Introducci\u00f3"},{"location":"unitats/pyside6/pyside6-intro/#qt-i-pyside","text":"PySide \u00e9s la uni\u00f3 de Python amb el conjunt d'eines per a desenvolupament d'interf\u00edcies gr\u00e0fiques d'usuari multiplataforma Qt, desenvolupat per The Qt Company , com a part del projecte Qt for Python . \u00c9s una de les alternatives al paquet de biblioteca est\u00e0ndard Tkinter. Igual que Qt, PySide \u00e9s programari lliure. PySide \u00e9s compatible amb Linux/X11, macOS i Microsoft Windows. Tot i que hi ha documentaci\u00f3 espec\u00edfica de PySide disponible, tamb\u00e9 podem utilitzar la documentaci\u00f3 de Qt , tenint en compte que s'haur\u00e0 de traduir la sintaxi d'objectes i m\u00e8todes per adaptar-ho a Python.","title":"Qt i PySide"},{"location":"unitats/pyside6/pyside6-intro/#versions-de-pyside","text":"Hi ha hagut tres versions principals de PySide: PySide \u00e9s compatible amb Qt 4 PySide2 \u00e9s compatible amb Qt 5 PySide6 \u00e9s compatible amb Qt 6 La versi\u00f3 1 de PySide va ser llan\u00e7ada l'agost de 2009 baix llic\u00e8ncia LGPL per Nokia, aleshores propietaria de Qt, despr\u00e9s de no arribar a un acord amb els desenvolupadors de PyQt, Riverbank Computing, per canviar els seus termes de llic\u00e8ncia per incloure LGPL com a llic\u00e8ncia alternativa. Va donar suport a Qt 4 sota els sistemes operatius Linux/X11, Mac OS X, Microsoft Windows, Maemo i MeeGo, mentre que la comunitat PySide va afegir suport per a Android. Christian Tismer va iniciar PySide2 per portar PySide de Qt 4 a Qt 5 el 2015. Aleshores, el projecte es va incorporar al projecte Qt.Va ser llan\u00e7at el desembre de 2018. PySide6 es va llan\u00e7ar el desembre de 2020. Va afegir suport per a Qt 6 i va eliminar el suport per a totes les versions de Python anteriors a la 3.6. El projecte va comen\u00e7ar utilitzant Boost.Python de les biblioteques de Boost C++ per a enlla\u00e7ar el codi Python amb les crides C++, llenguatge sobre el que est\u00e0 contru\u00eft Qt. M\u00e9s tard va crear el seu propi generador d'enlla\u00e7 anomenat Shiboken, per reduir la mida dels executables i l'\u00fas de mem\u00f2ria. Nosaltres farem \u00fas de PySide6 durant el present curs.","title":"Versions de PySide"},{"location":"unitats/pyside6/pyside6-intro/#installacio-de-pyside6","text":"Sempre que desenvolupem, hauriem de fer-ho en un entorn virtual. Recordeu que per crear-lo i activar-lo, utilitzem: python3 -m venv .venv source .venv/bin/activate #Per a Linux i macOS env\\Scripts\\activate.bat #Per a Windows Per a instal\u00b7lar PySide6 utilitzem pip : pip install pyside6","title":"Instal\u00b7laci\u00f3 de PySide6"},{"location":"unitats/pyside6/pyside6-intro/#comprovem-la-installacio","text":"Una vegada instal\u00b7lat i amb l'entorn virtual activat, podem executar el seg\u00fcent codi per comprovar que tot funciona. import PySide6.QtCore # Prints PySide6 version print(PySide6.__version__) # Prints the Qt version used to compile PySide6 print(PySide6.QtCore.__version__)","title":"Comprovem la Instal\u00b7laci\u00f3"},{"location":"unitats/pyside6/pyside6-intro/#primera-aplicacio-amb-pyside6-hola-mon","text":"","title":"Primera aplicaci\u00f3 amb PySide6 - Hola m\u00f3n!"},{"location":"unitats/pyside6/pyside6-intro/#exemple-hola-mon-amb-pyside6","text":"from PySide6 import QtWidgets, QtCore # Sols si necessitem arguments importem sys import sys if __name__ == \"__main__\": # Necessitem una inst\u00e0ncia (i sols una) de QApplication per cada aplicaci\u00f3. # Li passem sys.argv per a permetre arguments des de la l\u00ednia de comandaments # Si no anem a passar arguments podem utilitzar QApplication([]) app = QtWidgets.QApplication(sys.argv) # Creem un QLabel amb el text Hola m\u00f3n! i aliniament al centre. label = QtWidgets.QLabel(\"Hola m\u00f3n!\", alignment=QtCore.Qt.AlignCenter) # Redimensionem el QLabel label.resize(800, 600) #Fem visible el label IMPORTANT!!!!! Els components estan ocults per defecte. label.show() # Iniciem el bucle d\u2019esdeveniments. sys.exit(app.exec()) Si rebeu l'error libOpenGL.so.0: cannot open shared object file: No such file or directory , heu d'instal\u00b7lar la llibreria libopengl0 . sudo apt install libopengl0 -y Baixeu el codi d'ac\u00ed","title":"Exemple: Hola m\u00f3n! amb PySide6"},{"location":"unitats/pyside6/pyside6-intro/#que-es-una-finestra","text":"Cont\u00e9 la interf\u00edcie de l\u2019usuari Cada aplicaci\u00f3 en necessita almenys una, per\u00f2 en pot tindre m\u00e9s L\u2019aplicaci\u00f3, per defecte, acabar\u00e0 en tancar l\u2019\u00faltima d\u2019elles","title":"Qu\u00e8 \u00e9s una finestra?"},{"location":"unitats/pyside6/pyside6-intro/#que-es-el-bucle-desdeveniments-event-loop","text":"Ja hem vist que cada aplicaci\u00f3 necessita un i sols un objecte QApplication. Aquest objecte gestiona els esdeveniments. Cada una de les interaccions de l\u2019usuari amb la interf\u00edcie, per exemple, un clic de ratol\u00ed sobre un element, genera un esdeveniment. L\u2019esdeveniment es col\u00b7loca a la cola d\u2019esdeveniments per ser gestionat ( event queue ). Al bucle d'esdeveniments ( event loop ), la cua es comprova a cada iteraci\u00f3 i si es troba un esdeveniment en espera, l'esdeveniment i el control es passen al gestor de l\u2019esdeveniment ( event handler ). El gestor d'esdeveniments s'ocupa de l'esdeveniment i despr\u00e9s passa de nou el control al bucle d'esdeveniments per esperar m\u00e9s esdeveniments. Nom\u00e9s hi ha un bucle d'esdeveniments per aplicaci\u00f3.","title":"Qu\u00e8 \u00e9s el bucle d\u2019esdeveniments (event loop)?"},{"location":"unitats/pyside6/pyside6-intro/#qmainwindow","text":"Es tracta d\u2019un component pre-definit que proporciona moltes funcions est\u00e0ndard de les finestres que fareu servir les vostres aplicacions, com poden ser les barres d'eines, els men\u00fas, la barra d'estat, els components que es poden acoblar, etc. Veurem aquestes funcions avan\u00e7ades m\u00e9s endavant, per\u00f2 de moment anem a fer \u00fas d\u2019ella a la nostra aplicaci\u00f3.","title":"QMainWindow"},{"location":"unitats/pyside6/pyside6-intro/#activitat-1","text":"Anem a crear la nostra primera aplicaci\u00f3. Has de definir una classe MainWindow, que herede de QmainWindow. Amb el m\u00e8tode setWindowTitle() posa-li t\u00edtol a l\u2019aplicaci\u00f3 \u00abLa meua aplicaci\u00f3\u00bb. Amb QPushButton(), crea un bot\u00f3 amb el text, \u00abAceptar\u00bb. Afig el bot\u00f3 a la part central de la finestra amb setCentralWidget(\u00abcomponent\u00bb). Recorda mostrar la finestra i iniciar el bucle d\u2019esdeveniments.","title":"Activitat 1"},{"location":"unitats/pyside6/pyside6-intro/#activitat-2","text":"Modifica el codi de l\u2019anterior activitat per a que es puga passar per l\u00ednia de comandaments el t\u00edtol i el text del bot\u00f3. python3 activitat2.2.py \"APP\" \"Text\"","title":"Activitat 2"},{"location":"unitats/pyside6/pyside6-intro/#assignem-tamany-a-les-finestres-i-els-components","text":"Amb la funcions .setFixedSize(amplada, altura) assignem una mida fixa al component sobre el que l\u2019apliquem. Amb .setMinimumSize(amplada, altura) i setMaximumSize(amplada, altura) , assignem les mides m\u00e0ximes i m\u00ednimes, de forma que ni redimensionant amb el ratol\u00ed ni amb els botons de maximitzar i minimitzar tindrem la possibilitat d\u2019establir unes dimensions menors o majors de les establides. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self, title=\"Title\", button_text=\"Text\", fixed=False): super().__init__() self.setWindowTitle(title) self.button = QPushButton(button_text) self.setCentralWidget(self.button) #self.setFixedSize(400,600) self.button.setMaximumSize(100,25) self.setMaximumSize(400,400) self.setMinimumSize(200,200) self.button.show() self.show() app = QApplication(sys.argv) window = MainWindow() app.exec() Baixa el codi punxant el seg\u00fcent enlla\u00e7","title":"Assignem tamany a les finestres i els components"},{"location":"unitats/pyside6/pyside6-intro/#activitat-3-entregable","text":"Basant-nos en el codi de l'activitat 2, anem a fer una gesti\u00f3 m\u00e9s pr\u00e0ctica i real dels par\u00e0metres d'entrada de l'script. Este \u00e9s l'aspecte que tindr\u00e0 l'ajuda de l'execuci\u00f3 de l'script. usage: finestra3_args.py [-h] [-t TITLE] [-b BUTTON_TEXT] [-f] [-s SIZE SIZE] optional arguments: -h, --help show this help message and exit -t TITLE, --title TITLE Title of application -b BUTTON_TEXT, --button-text BUTTON_TEXT Button text -f, --fixed-size Window fixed size -s SIZE SIZE, --size SIZE SIZE Size of windows Per a fer tota aquesta gesti\u00f3, busca una llibreria de python que t'ajude.","title":"Activitat 3 (entregable)"},{"location":"unitats/pyside6/pyside6-layouts/","text":"Gesti\u00f3 del layout Fins ara hem creat una finestra i hi hem afegit un widget . Tanmateix, normalment volem afegir m\u00e9s d'un widget a una finestra i tenir cert control sobre on va a parar. Per fer-ho a Qt fem servir layouts . Hi ha 4 dissenys b\u00e0sics disponibles a Qt, que s'enumeren a la taula seg\u00fcent. Layout Comportament QHBoxLayout Disseny horitzontal QVBoxLayout Disseny vertical QGridLayout Disseny de graella indexable XxY QStackedLayout Apilats en profunditat Com podeu veure, hi ha tres dissenys posicionals disponibles a Qt. El VBoxLayout, QHBoxLayout i QGridLayout. A m\u00e9s, tamb\u00e9 hi ha QStackedLayout que us permet col\u00b7locar widgets un damunt de l'altre dins del mateix espai, tot i que mostra nom\u00e9s un layout alhora. M\u00e9s endavant utilitzarem uns ferramenta gr\u00e0fica per definir el layout . Classe Color Per facilitar la visualitzaci\u00f3 dels dissenys, primer crearem un widget personalitzat senzill que mostre un color s\u00f2lid que triem. Aix\u00f2 ajudar\u00e0 a distingir els widgets que afegim al disseny. from PySide6.QtGui import QPalette, QColor from PySide6.QtWidgets import QWidget class Color(QWidget): def __init__(self, color): super(Color, self).__init__() self.setAutoFillBackground(True) palette = self.palette() palette.setColor(QPalette.Window, QColor(color)) self.setPalette(palette) En aquest codi subclassem QWidget per crear el nostre propi widget personalitzat Color. Acceptem un \u00fanic par\u00e0metre a l'hora de crear un objecte Color: Color(un str). Primer establim . setAutoFillBackground a True per dir-li al widget que ompliga autom\u00e0ticament el seu fons amb el color que li hem passat. A continuaci\u00f3, obtenim la paleta actual (que \u00e9s la paleta global de l'escriptori per defecte) i canviem el color QPalette.Window actual a un nou QColor descrit pel color del valor que hem passat. Finalment, tornem a aplicar aquesta paleta al widget . El resultat final \u00e9s un widget que s'omple amb un color s\u00f2lid, qu\u00e8 vam especificar quan el vam crear. M\u00e9s endavant tractarem els widget s personalitzats amb m\u00e9s detall. Podeu establir l'espaiat al voltant del disseny amb .setContentMargins o establir l'espai entre elements amb .setSpacing . QVBoxLayout El layout vertical va afegint els widgets un damunt de l'altre. Si afegim un nou widget l'afegir\u00e0 a la part de baix. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QVBoxLayout() layout.addWidget(Color('red')) layout.addWidget(Color('green')) layout.addWidget(Color('blue')) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() QHBoxLayout El layout horitzontal va afegint els components un al costat de l'altre. Si afegim un nou component, l'afegir\u00e0 a l'esquerra. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QHBoxLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QHBoxLayout() layout.addWidget(Color('red')) layout.addWidget(Color('green')) layout.addWidget(Color('blue')) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Layouts anidats Per a dissenys m\u00e9s complexos, podem niuar els dissenys els uns dintre dels altres mitjan\u00e7ant .addLayout en un disseny. A continuaci\u00f3, afegim un QVBoxLayout al QHBoxLayout principal. Si afegim alguns widgets al QVBoxLayout , estaran disposats verticalment a la primera ranura del disseny principal. import sys from PySide6.QtWidgets import ( QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout1 = QHBoxLayout() layout2 = QVBoxLayout() layout3 = QVBoxLayout() layout1.setContentsMargins(0,0,0,0) layout1.setSpacing(0) layout2.addWidget(Color('red')) layout2.addWidget(Color('yellow')) layout2.addWidget(Color('purple')) layout1.addLayout(layout2) layout1.addWidget(Color('green')) layout3.addWidget(Color('red')) layout3.addWidget(Color('purple')) layout1.addLayout( layout3 ) widget = QWidget() widget.setLayout(layout1) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() QGridLayout Per molt \u00fatils que siguen, si proveu d'utilitzar QVBoxLayout i QHBoxLayout per dissenyar diversos elements, per exemple a un formulari, us ser\u00e0 molt dif\u00edcil assegurar-vos que els components de mida diferent s'alinein. La soluci\u00f3 a aix\u00f2 \u00e9s QGridLayout . QGridLayout us permet posicionar elements espec\u00edficament en una quadr\u00edcula. Especifiqueu les posicions de fila i columna per a cada component. Podeu ometre elements i es deixaran buits. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QGridLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QGridLayout() layout.addWidget(Color('red'), 0, 0) layout.addWidget(Color('green'), 1, 0) layout.addWidget(Color('blue'), 1, 1) layout.addWidget(Color('purple'), 2, 1) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() QStackedLayout molts widgets al mateix espai El disseny final que tractarem \u00e9s el QStackedLayout. Tal com es descriu, aquest disseny us permet col\u00b7locar elements directament els uns damunt dels altres (apilats). A continuaci\u00f3, podeu seleccionar quin disseny voleu mostrar. Podeu utilitzar-lo per dibuixar capes en una aplicaci\u00f3 gr\u00e0fica o per imitar una interf\u00edcie semblant a una pestanya. Tingueu en compte que tamb\u00e9 hi ha QStackedWidget , que \u00e9s un component de contenidor que funciona exactament de la mateixa manera. Aix\u00f2 \u00e9s \u00fatil si voleu afegir una pila de components directament a un QMainWindow amb setCentralWidget . QStackedWidget \u00e9s exactament com funcionen les vistes amb pestanyes a les aplicacions. Nom\u00e9s una pestanya \u00e9s visible alhora. Podeu controlar quin components mostrar en qualsevol moment utilitzant .setCurrentIndex() o .setCurrentWidget() per establir l'element mitjan\u00e7ant l'\u00edndex o per la refer\u00e8ncia al propi component. A continuaci\u00f3 es mostra una breu demostraci\u00f3 amb QStackedLayout en combinaci\u00f3 amb QButton per proporcionar una interf\u00edcie semblant a una pestanya a una aplicaci\u00f3: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QHBoxLayout, QLabel, QMainWindow, QPushButton, QStackedLayout, QVBoxLayout, QWidget, ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") pagelayout = QVBoxLayout() button_layout = QHBoxLayout() self.stacklayout = QStackedLayout() pagelayout.addLayout(button_layout) pagelayout.addLayout(self.stacklayout) btn = QPushButton(\"red\") btn.pressed.connect(self.activate_tab_1) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"red\")) btn = QPushButton(\"green\") btn.pressed.connect(self.activate_tab_2) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"green\")) btn = QPushButton(\"yellow\") btn.pressed.connect(self.activate_tab_3) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"yellow\")) widget = QWidget() widget.setLayout(pagelayout) self.setCentralWidget(widget) def activate_tab_1(self): self.stacklayout.setCurrentIndex(0) def activate_tab_2(self): self.stacklayout.setCurrentIndex(1) def activate_tab_3(self): self.stacklayout.setCurrentIndex(2) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() El resultat \u00e9s la seg\u00fcent aplicaci\u00f3: QTabWidget Qt en realitat proporciona un TabWidget que proporciona aquest tipus de disseny en forma de widget. Vegeu el seg\u00fcent exemple amb QTabWidget: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QLabel, QMainWindow, QPushButton, QTabWidget, QWidget, ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") tabs = QTabWidget() tabs.setTabPosition(QTabWidget.West) tabs.setMovable(True) for n, color in enumerate([\"red\", \"green\", \"blue\", \"yellow\"]): tabs.addTab(Color(color), color) self.setCentralWidget(tabs) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Com podeu veure, \u00e9s una mica m\u00e9s senzill i una mica m\u00e9s atractiu! Podeu establir la posici\u00f3 de les pestanyes mitjan\u00e7ant les direccions cardinals, canviar si les pestanyes es poden moure amb .setMoveable . Notareu que la barra de pestanyes de macOS t\u00e9 un aspecte molt diferent de les altres; de manera predeterminada, les pestanyes de macOS adopten un estil de pastilla o bombolla. A macOS, normalment s'utilitza per als panells de configuraci\u00f3 amb pestanyes. Per als documents, podeu activar el mode de document per oferir pestanyes esveltes semblants a les que veieu a altres plataformes. Aquesta opci\u00f3 no t\u00e9 cap efecte en altres plataformes.","title":"Layouts"},{"location":"unitats/pyside6/pyside6-layouts/#gestio-del-layout","text":"Fins ara hem creat una finestra i hi hem afegit un widget . Tanmateix, normalment volem afegir m\u00e9s d'un widget a una finestra i tenir cert control sobre on va a parar. Per fer-ho a Qt fem servir layouts . Hi ha 4 dissenys b\u00e0sics disponibles a Qt, que s'enumeren a la taula seg\u00fcent. Layout Comportament QHBoxLayout Disseny horitzontal QVBoxLayout Disseny vertical QGridLayout Disseny de graella indexable XxY QStackedLayout Apilats en profunditat Com podeu veure, hi ha tres dissenys posicionals disponibles a Qt. El VBoxLayout, QHBoxLayout i QGridLayout. A m\u00e9s, tamb\u00e9 hi ha QStackedLayout que us permet col\u00b7locar widgets un damunt de l'altre dins del mateix espai, tot i que mostra nom\u00e9s un layout alhora. M\u00e9s endavant utilitzarem uns ferramenta gr\u00e0fica per definir el layout .","title":"Gesti\u00f3 del layout"},{"location":"unitats/pyside6/pyside6-layouts/#classe-color","text":"Per facilitar la visualitzaci\u00f3 dels dissenys, primer crearem un widget personalitzat senzill que mostre un color s\u00f2lid que triem. Aix\u00f2 ajudar\u00e0 a distingir els widgets que afegim al disseny. from PySide6.QtGui import QPalette, QColor from PySide6.QtWidgets import QWidget class Color(QWidget): def __init__(self, color): super(Color, self).__init__() self.setAutoFillBackground(True) palette = self.palette() palette.setColor(QPalette.Window, QColor(color)) self.setPalette(palette) En aquest codi subclassem QWidget per crear el nostre propi widget personalitzat Color. Acceptem un \u00fanic par\u00e0metre a l'hora de crear un objecte Color: Color(un str). Primer establim . setAutoFillBackground a True per dir-li al widget que ompliga autom\u00e0ticament el seu fons amb el color que li hem passat. A continuaci\u00f3, obtenim la paleta actual (que \u00e9s la paleta global de l'escriptori per defecte) i canviem el color QPalette.Window actual a un nou QColor descrit pel color del valor que hem passat. Finalment, tornem a aplicar aquesta paleta al widget . El resultat final \u00e9s un widget que s'omple amb un color s\u00f2lid, qu\u00e8 vam especificar quan el vam crear. M\u00e9s endavant tractarem els widget s personalitzats amb m\u00e9s detall. Podeu establir l'espaiat al voltant del disseny amb .setContentMargins o establir l'espai entre elements amb .setSpacing .","title":"Classe Color"},{"location":"unitats/pyside6/pyside6-layouts/#qvboxlayout","text":"El layout vertical va afegint els widgets un damunt de l'altre. Si afegim un nou widget l'afegir\u00e0 a la part de baix. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QVBoxLayout() layout.addWidget(Color('red')) layout.addWidget(Color('green')) layout.addWidget(Color('blue')) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec()","title":"QVBoxLayout"},{"location":"unitats/pyside6/pyside6-layouts/#qhboxlayout","text":"El layout horitzontal va afegint els components un al costat de l'altre. Si afegim un nou component, l'afegir\u00e0 a l'esquerra. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QHBoxLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QHBoxLayout() layout.addWidget(Color('red')) layout.addWidget(Color('green')) layout.addWidget(Color('blue')) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec()","title":"QHBoxLayout"},{"location":"unitats/pyside6/pyside6-layouts/#layouts-anidats","text":"Per a dissenys m\u00e9s complexos, podem niuar els dissenys els uns dintre dels altres mitjan\u00e7ant .addLayout en un disseny. A continuaci\u00f3, afegim un QVBoxLayout al QHBoxLayout principal. Si afegim alguns widgets al QVBoxLayout , estaran disposats verticalment a la primera ranura del disseny principal. import sys from PySide6.QtWidgets import ( QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout1 = QHBoxLayout() layout2 = QVBoxLayout() layout3 = QVBoxLayout() layout1.setContentsMargins(0,0,0,0) layout1.setSpacing(0) layout2.addWidget(Color('red')) layout2.addWidget(Color('yellow')) layout2.addWidget(Color('purple')) layout1.addLayout(layout2) layout1.addWidget(Color('green')) layout3.addWidget(Color('red')) layout3.addWidget(Color('purple')) layout1.addLayout( layout3 ) widget = QWidget() widget.setLayout(layout1) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec()","title":"Layouts anidats"},{"location":"unitats/pyside6/pyside6-layouts/#qgridlayout","text":"Per molt \u00fatils que siguen, si proveu d'utilitzar QVBoxLayout i QHBoxLayout per dissenyar diversos elements, per exemple a un formulari, us ser\u00e0 molt dif\u00edcil assegurar-vos que els components de mida diferent s'alinein. La soluci\u00f3 a aix\u00f2 \u00e9s QGridLayout . QGridLayout us permet posicionar elements espec\u00edficament en una quadr\u00edcula. Especifiqueu les posicions de fila i columna per a cada component. Podeu ometre elements i es deixaran buits. import sys from PySide6.QtWidgets import QApplication, QMainWindow, QWidget, QGridLayout from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") layout = QGridLayout() layout.addWidget(Color('red'), 0, 0) layout.addWidget(Color('green'), 1, 0) layout.addWidget(Color('blue'), 1, 1) layout.addWidget(Color('purple'), 2, 1) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec()","title":"QGridLayout"},{"location":"unitats/pyside6/pyside6-layouts/#qstackedlayout-molts-widgets-al-mateix-espai","text":"El disseny final que tractarem \u00e9s el QStackedLayout. Tal com es descriu, aquest disseny us permet col\u00b7locar elements directament els uns damunt dels altres (apilats). A continuaci\u00f3, podeu seleccionar quin disseny voleu mostrar. Podeu utilitzar-lo per dibuixar capes en una aplicaci\u00f3 gr\u00e0fica o per imitar una interf\u00edcie semblant a una pestanya. Tingueu en compte que tamb\u00e9 hi ha QStackedWidget , que \u00e9s un component de contenidor que funciona exactament de la mateixa manera. Aix\u00f2 \u00e9s \u00fatil si voleu afegir una pila de components directament a un QMainWindow amb setCentralWidget . QStackedWidget \u00e9s exactament com funcionen les vistes amb pestanyes a les aplicacions. Nom\u00e9s una pestanya \u00e9s visible alhora. Podeu controlar quin components mostrar en qualsevol moment utilitzant .setCurrentIndex() o .setCurrentWidget() per establir l'element mitjan\u00e7ant l'\u00edndex o per la refer\u00e8ncia al propi component. A continuaci\u00f3 es mostra una breu demostraci\u00f3 amb QStackedLayout en combinaci\u00f3 amb QButton per proporcionar una interf\u00edcie semblant a una pestanya a una aplicaci\u00f3: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QHBoxLayout, QLabel, QMainWindow, QPushButton, QStackedLayout, QVBoxLayout, QWidget, ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") pagelayout = QVBoxLayout() button_layout = QHBoxLayout() self.stacklayout = QStackedLayout() pagelayout.addLayout(button_layout) pagelayout.addLayout(self.stacklayout) btn = QPushButton(\"red\") btn.pressed.connect(self.activate_tab_1) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"red\")) btn = QPushButton(\"green\") btn.pressed.connect(self.activate_tab_2) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"green\")) btn = QPushButton(\"yellow\") btn.pressed.connect(self.activate_tab_3) button_layout.addWidget(btn) self.stacklayout.addWidget(Color(\"yellow\")) widget = QWidget() widget.setLayout(pagelayout) self.setCentralWidget(widget) def activate_tab_1(self): self.stacklayout.setCurrentIndex(0) def activate_tab_2(self): self.stacklayout.setCurrentIndex(1) def activate_tab_3(self): self.stacklayout.setCurrentIndex(2) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() El resultat \u00e9s la seg\u00fcent aplicaci\u00f3:","title":"QStackedLayout molts widgets al mateix espai"},{"location":"unitats/pyside6/pyside6-layouts/#qtabwidget","text":"Qt en realitat proporciona un TabWidget que proporciona aquest tipus de disseny en forma de widget. Vegeu el seg\u00fcent exemple amb QTabWidget: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QLabel, QMainWindow, QPushButton, QTabWidget, QWidget, ) from color_widget import Color class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") tabs = QTabWidget() tabs.setTabPosition(QTabWidget.West) tabs.setMovable(True) for n, color in enumerate([\"red\", \"green\", \"blue\", \"yellow\"]): tabs.addTab(Color(color), color) self.setCentralWidget(tabs) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Com podeu veure, \u00e9s una mica m\u00e9s senzill i una mica m\u00e9s atractiu! Podeu establir la posici\u00f3 de les pestanyes mitjan\u00e7ant les direccions cardinals, canviar si les pestanyes es poden moure amb .setMoveable . Notareu que la barra de pestanyes de macOS t\u00e9 un aspecte molt diferent de les altres; de manera predeterminada, les pestanyes de macOS adopten un estil de pastilla o bombolla. A macOS, normalment s'utilitza per als panells de configuraci\u00f3 amb pestanyes. Per als documents, podeu activar el mode de document per oferir pestanyes esveltes semblants a les que veieu a altres plataformes. Aquesta opci\u00f3 no t\u00e9 cap efecte en altres plataformes.","title":"QTabWidget"},{"location":"unitats/pyside6/pyside6-signals-slots/","text":"Senyals i ranures (signal & slots) En l\u2019anterior aplicaci\u00f3 hem incl\u00f2s un bot\u00f3, per\u00f2 que no executa ninguna acci\u00f3 al fer clic sobre ell. Necessitem connectar les accions a alguna funcionalitat. En Qt, a\u00e7\u00f2 s\u2019aconseguix gr\u00e0cies a les senyals i les ranures. Una senyal \u00e9s una notificaci\u00f3 emesa pels components quan es produeix un esdeveniment. Una ranura \u00e9s el nom que Qt dona als rebedors de senyals. En Python, qualsevol funci\u00f3 pot ser una ranura, simplement connectant-li una senyal. from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton from PySide6.QtCore import QSize class MainWindow(QMainWindow): def __init__(self): QMainWindow.__init__(self) self.setFixedSize(QSize(300, 300)) self.setWindowTitle(\"Exemple signals-slots 1\") pybutton = QPushButton('Clic', self) #Connectem la senyal clicked a la ranura button_pressed pybutton.clicked.connect(self.button_pressed) pybutton.resize(100, 100) pybutton.move(100, 100) def button_pressed(self): ''' S'executa\u00e0 al rebre la notificaci\u00f3 de que s'ha apretat el bot\u00f3: - Observeu que la consola imprimir\u00e0 \"Clic rebut!\" al fer clic al bot\u00f3 ''' print('Clic rebut!') if __name__ == \"__main__\": app = QApplication([]) mainWin = MainWindow() mainWin.show() app.exec() Pots baixar el codi ac\u00ed En l'anterior codi, a m\u00e9s de connectar la senyal a l'slot, hem utilitzat les funcions resize i move per a assignar el tamany i situar un component. Consulta la documentaci\u00f3 per obtindre m\u00e9s informaci\u00f3 sobre les senyals de QPushButton . Activitat 4 (entregable) Fes una aplicaci\u00f3 amb tres botons. Inicialment, l'aplicaci\u00f3 ocupar\u00e0 el tamany normalitzat i els botons estaran centrats, tant verticalment com horitzontalment en tot moment: - Inicialment l'aplicaci\u00f3 es mostrar\u00e0 centrada sobre la pantalla amb el tamany normalitzat. - Al fer clic al bot\u00f3 de l'esquerra Maximitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00e0xim definit. - Al fer clic al bot\u00f3 de la dreta Minimitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00ednim definit. - Al fer clic al bot\u00f3 central Normalitza , l'aplicaci\u00f3 passar\u00e0 a ocupar de nou el tamany normalitzat. - En cada cas, els botons es deshabilitzaran segons corresponga. \u00c9s a dir, en tamany normalitzat, el bot\u00f3 corresponent a normalitzar el tamany estar\u00e0 deshabilitat i la restat habilitats. Per a la resta de tamanys, aplicarem el mateix criteri. - El tamanys normal, m\u00e0xim i m\u00ednim de finestra, aix\u00ed com els tamanys de bot\u00f3 estaran definits a un arxiu config.py - El tamany m\u00ednim mai podr\u00e0 ser inferior a la suma dels tamanys de bot\u00f3. - El title de l'aplicaci\u00f3 mostrar\u00e0 en cada moment en quin estat es troba Normalitzat, Maximitzat o Minimitzat Encadenaments de senyals Fixa't en l'exemple seg\u00fcent: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") button = QPushButton(\"Press Me!\") button.setCheckable(True) button.clicked.connect(self.the_button_was_clicked) button.clicked.connect(self.the_button_was_toggled) self.windowTitleChanged.connect(self.the_window_title_changed) # Set the central widget of the Window. self.setCentralWidget(button) def the_button_was_clicked(self): if self.windowTitle() == \"La meua aplicaci\u00f3\": self.setWindowTitle(\"My App\") else: self.setWindowTitle(\"La meua aplicaci\u00f3\") def the_button_was_toggled(self): print(\"Clic rebut!\") def the_window_title_changed(self, window_title): print(\"Window title changed: %s\" % window_title) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Treballant amb senyals i ranures hem de tindre en compte: - Un \u00fanic senyal pot estar connectat a diverses ranures -> Clic desencadena l'execuci\u00f3 de the_button_was_toggled i the_button_was_clicked . - Les ranures poden rebre arguments -> La ranura the_window_title_changed rep window_title com a argument. - Un \u00fanic esdeveniments pot desencadenar l'emissi\u00f3 de diverses senyals connectades entre elles a trav\u00e9s d'una ranura -> Al fer clic es llan\u00e7a l'execuci\u00f3 de the_button_was_clicked , que a la vegada desencadena l'esdeveniment windowTitleChanged . Connectem components entre si No sempre necessitem definir una funci\u00f3 per gestionar un esdeveniment, podem connectar components entre si per fer-ho: import sys from PySide6.QtWidgets import QApplication, QMainWindow, QLabel, QLineEdit, QVBoxLayout, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") container = QWidget() container.setFixedSize(240,100) self.label = QLabel(container) self.label.setFixedSize(200,20) self.label.move(20, 20) self.input = QLineEdit(container) self.input.setFixedSize(200,20) self.input.move(20, 60) self.input.textChanged.connect(self.label.setText) self.setCentralWidget(container) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Quan canviem el text del LineEdit , el senyal textChanged envia el text a la ranura a la qual est\u00e0 connectada, en aquest cas \u00e9s la funci\u00f3 setText del Label , canviant aix\u00ed el seu text. Senyals definits per l'usuari Fins ara hem utilitzat els senyals predefinits pels components Qt. Definirem ara els nostres propis senyals. Aix\u00f2 ens ajudar\u00e0 a desacoblar (independitzar, fer que no depenguen unes de altres) les diferents part del programa. A m\u00e9s, ens permetr\u00e0 fer la nostra aplicaci\u00f3 responsiva , en compte de tindre un gran m\u00e8tode update , podem partir el treball entre m\u00faltiples ranures i llan\u00e7ar-les amb una sola senyal. Utilitzarem la classe Signal amb els tipus que ens interesse: import sys from PySide6.QtCore import Qt, Signal from PySide6.QtWidgets import QApplication, QMainWindow class MainWindow(QMainWindow): message = Signal(str) value = Signal(int, str, int) another = Signal(list) onemore = Signal(dict) anything = Signal(object) def __init__(self): super().__init__() self.message.connect(self.custom_slot) self.value.connect(self.custom_slot) self.another.connect(self.custom_slot) self.onemore.connect(self.custom_slot) self.anything.connect(self.custom_slot) self.message.emit(\"my message\") self.value.emit(23, \"abc\", 1) self.another.emit([1, 2, 3, 4, 5]) self.onemore.emit({\"a\": 2, \"b\": 7}) self.anything.emit(1223) def custom_slot(self, a): print(a) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Podeu baixar el codi ac\u00ed Com podeu observar, utilitzem el m\u00e8tode emit per a llan\u00e7ar el senyal, que \u00e9s capa\u00e7 de transmetre informaci\u00f3 de qualsevol tipus, per\u00f2 no \u00e9s una bona idea que les ranures reben qualsevol tipus, ja que s'hauria de gestionar a la funci\u00f3, cosa que la complicaria molt. Pots crear senyals en qualsevol subclasse de QObject , incl\u00f2s components, finestres i dialegs. Modifiquem la informaci\u00f3 emesa pels senyals Ja hem vist que els senyals poden emetre informaci\u00f3 a les ranures. Per\u00f2 els senyals predefinits, sols envien dades que s'ha definit que envien en el seu disseny. Per exemple, QPushButton.clicked sols envia el valor de checked despr\u00e9s de produir-se l'esdeveniment. Per a botons no seleccionable, setCheckable(False) , sempre enviar\u00e0 el valor False . Per solucionar este problema podem interceptar el senyal i modificar les dades: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self): super().__init__() btn = QPushButton(\"Press me\") btn.setCheckable(True) btn.clicked.connect(lambda checked: self.button_clicked(checked, btn)) self.setCentralWidget(btn) def button_clicked(self, checked, btn): print(btn, checked) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed En aquest cas, el senyal clicked emetr\u00e0 l'estat de checked . La funci\u00f3 lambda intercepta el senyal i afegeix la informaci\u00f3 de l'objecte btn . Activitat 5 Fes una aplicaci\u00f3 que tinga un bot\u00f3. Al fer clic sobre ell, s'executar\u00e0 una funci\u00f3 que rebr\u00e0 l'estat del bot\u00f3. A m\u00e9s, emetr\u00e0 un nou senyal connectat a una altra funci\u00f3, que rebr\u00e0 l'estat del senyal i un n\u00famero aleatori. Al rebre la nova funci\u00f3 el senyal, imprimir\u00e0 per pantalla els valors del l'estat del bot\u00f3 i el n\u00famero aleatori. Esdeveniments Cada interacci\u00f3 que l'usuari t\u00e9 amb una aplicaci\u00f3 Qt \u00e9s un esdeveniment. Hi ha molts tipus d'esdeveniments. Cada esdeveniment \u00e9s un objecte que empaqueta informaci\u00f3 sobre la interacci\u00f3 que l'ha produ\u00eft. Els esdeveniments es passen a controladors d'esdeveniments ( event handler ) espec\u00edfics del component on s'ha produ\u00eft la interacci\u00f3. Podem definir gestors d'esdeveniments personalitzats, modificant la manera com els vostres components responen a aquests esdeveniments. Els controladors d'esdeveniments es defineixen com qualsevol altre m\u00e8tode, per\u00f2 el nom \u00e9s espec\u00edfic per al tipus d'esdeveniment que gestionen. Un dels principals esdeveniments que reben els components \u00e9s el QMouseEvent. Els esdeveniments QMouseEvent es produixen en moure i clicar el ratol\u00ed sobre un component. Els seg\u00fcents gestors d'esdeveniments estan disponibles per gestionar els esdeveniments del ratol\u00ed: Gestor d'esdeveniment Tipus d'esdeveniment mouseMoveEvent Moviment de ratol\u00ed mousePressEvent Bot\u00f3 del ratol\u00ed premut mouseReleaseEvent Bot\u00f3 de ratol\u00ed soltat mouseDoubleClickEvent Doble clic detectat Per exemple, fer clic en un component provocar\u00e0 que s'envie un QMouseEvent al gestor d'esdeveniments .mousePressEvent del component. Aquest controlador pot utilitzar l'objecte d'esdeveniment per recollir informaci\u00f3 sobre qu\u00e8 ha passat, com ara qu\u00e8 va desencadenar l'esdeveniment i on concretament es va produir. Podeu interceptar esdeveniments heretant i anul\u00b7lant el m\u00e8tode del controlador a la classe derivada. Podeu triar filtrar, modificar o ignorar esdeveniments, passant-los al controlador normal de l'esdeveniment cridant a la funci\u00f3 de classe pare amb m\u00e8tode super(). Veiem a\u00e7\u00f2 amb una finestra principal. En cada cas, e rebr\u00e0 l'esdeveniment produ\u00eft. import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QTextEdit class MainWindow(QMainWindow): def __init__(self): super().__init__() self.label = QLabel(\"Click in this window\") self.setCentralWidget(self.label) def mouseMoveEvent(self, e): self.label.setText(\"mouseMoveEvent\") def mousePressEvent(self, e): self.label.setText(\"mousePressEvent\") def mouseReleaseEvent(self, e): self.label.setText(\"mouseReleaseEvent\") def mouseDoubleClickEvent(self, e): self.label.setText(\"mouseDoubleClickEvent\") app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Observeu que els esdeveniments de moviment del ratol\u00ed nom\u00e9s es registren quan teniu el bot\u00f3 premut. Podeu canviar-ho afegint un atribut al widget central i cridant ade la finestra. self.centralWidget().setAttribute(Qt.WA_TransparentForMouseEvents) self.setMouseTracking(False) Tamb\u00e9 podeu notar que els esdeveniments de clic i de doble clic es desencadenen quan es prem el bot\u00f3. Nom\u00e9s l'esdeveniment de soltar es dispara quan es deixa de pr\u00e9mer.","title":"Signals - Slots"},{"location":"unitats/pyside6/pyside6-signals-slots/#senyals-i-ranures-signal-slots","text":"En l\u2019anterior aplicaci\u00f3 hem incl\u00f2s un bot\u00f3, per\u00f2 que no executa ninguna acci\u00f3 al fer clic sobre ell. Necessitem connectar les accions a alguna funcionalitat. En Qt, a\u00e7\u00f2 s\u2019aconseguix gr\u00e0cies a les senyals i les ranures. Una senyal \u00e9s una notificaci\u00f3 emesa pels components quan es produeix un esdeveniment. Una ranura \u00e9s el nom que Qt dona als rebedors de senyals. En Python, qualsevol funci\u00f3 pot ser una ranura, simplement connectant-li una senyal. from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton from PySide6.QtCore import QSize class MainWindow(QMainWindow): def __init__(self): QMainWindow.__init__(self) self.setFixedSize(QSize(300, 300)) self.setWindowTitle(\"Exemple signals-slots 1\") pybutton = QPushButton('Clic', self) #Connectem la senyal clicked a la ranura button_pressed pybutton.clicked.connect(self.button_pressed) pybutton.resize(100, 100) pybutton.move(100, 100) def button_pressed(self): ''' S'executa\u00e0 al rebre la notificaci\u00f3 de que s'ha apretat el bot\u00f3: - Observeu que la consola imprimir\u00e0 \"Clic rebut!\" al fer clic al bot\u00f3 ''' print('Clic rebut!') if __name__ == \"__main__\": app = QApplication([]) mainWin = MainWindow() mainWin.show() app.exec() Pots baixar el codi ac\u00ed En l'anterior codi, a m\u00e9s de connectar la senyal a l'slot, hem utilitzat les funcions resize i move per a assignar el tamany i situar un component. Consulta la documentaci\u00f3 per obtindre m\u00e9s informaci\u00f3 sobre les senyals de QPushButton .","title":"Senyals i ranures (signal &amp; slots)"},{"location":"unitats/pyside6/pyside6-signals-slots/#activitat-4-entregable","text":"Fes una aplicaci\u00f3 amb tres botons. Inicialment, l'aplicaci\u00f3 ocupar\u00e0 el tamany normalitzat i els botons estaran centrats, tant verticalment com horitzontalment en tot moment: - Inicialment l'aplicaci\u00f3 es mostrar\u00e0 centrada sobre la pantalla amb el tamany normalitzat. - Al fer clic al bot\u00f3 de l'esquerra Maximitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00e0xim definit. - Al fer clic al bot\u00f3 de la dreta Minimitza , l'aplicaci\u00f3 passar\u00e0 a ocupar el tamany m\u00ednim definit. - Al fer clic al bot\u00f3 central Normalitza , l'aplicaci\u00f3 passar\u00e0 a ocupar de nou el tamany normalitzat. - En cada cas, els botons es deshabilitzaran segons corresponga. \u00c9s a dir, en tamany normalitzat, el bot\u00f3 corresponent a normalitzar el tamany estar\u00e0 deshabilitat i la restat habilitats. Per a la resta de tamanys, aplicarem el mateix criteri. - El tamanys normal, m\u00e0xim i m\u00ednim de finestra, aix\u00ed com els tamanys de bot\u00f3 estaran definits a un arxiu config.py - El tamany m\u00ednim mai podr\u00e0 ser inferior a la suma dels tamanys de bot\u00f3. - El title de l'aplicaci\u00f3 mostrar\u00e0 en cada moment en quin estat es troba Normalitzat, Maximitzat o Minimitzat","title":"Activitat 4 (entregable)"},{"location":"unitats/pyside6/pyside6-signals-slots/#encadenaments-de-senyals","text":"Fixa't en l'exemple seg\u00fcent: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") button = QPushButton(\"Press Me!\") button.setCheckable(True) button.clicked.connect(self.the_button_was_clicked) button.clicked.connect(self.the_button_was_toggled) self.windowTitleChanged.connect(self.the_window_title_changed) # Set the central widget of the Window. self.setCentralWidget(button) def the_button_was_clicked(self): if self.windowTitle() == \"La meua aplicaci\u00f3\": self.setWindowTitle(\"My App\") else: self.setWindowTitle(\"La meua aplicaci\u00f3\") def the_button_was_toggled(self): print(\"Clic rebut!\") def the_window_title_changed(self, window_title): print(\"Window title changed: %s\" % window_title) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Treballant amb senyals i ranures hem de tindre en compte: - Un \u00fanic senyal pot estar connectat a diverses ranures -> Clic desencadena l'execuci\u00f3 de the_button_was_toggled i the_button_was_clicked . - Les ranures poden rebre arguments -> La ranura the_window_title_changed rep window_title com a argument. - Un \u00fanic esdeveniments pot desencadenar l'emissi\u00f3 de diverses senyals connectades entre elles a trav\u00e9s d'una ranura -> Al fer clic es llan\u00e7a l'execuci\u00f3 de the_button_was_clicked , que a la vegada desencadena l'esdeveniment windowTitleChanged .","title":"Encadenaments de senyals"},{"location":"unitats/pyside6/pyside6-signals-slots/#connectem-components-entre-si","text":"No sempre necessitem definir una funci\u00f3 per gestionar un esdeveniment, podem connectar components entre si per fer-ho: import sys from PySide6.QtWidgets import QApplication, QMainWindow, QLabel, QLineEdit, QVBoxLayout, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") container = QWidget() container.setFixedSize(240,100) self.label = QLabel(container) self.label.setFixedSize(200,20) self.label.move(20, 20) self.input = QLineEdit(container) self.input.setFixedSize(200,20) self.input.move(20, 60) self.input.textChanged.connect(self.label.setText) self.setCentralWidget(container) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Quan canviem el text del LineEdit , el senyal textChanged envia el text a la ranura a la qual est\u00e0 connectada, en aquest cas \u00e9s la funci\u00f3 setText del Label , canviant aix\u00ed el seu text.","title":"Connectem components entre si"},{"location":"unitats/pyside6/pyside6-signals-slots/#senyals-definits-per-lusuari","text":"Fins ara hem utilitzat els senyals predefinits pels components Qt. Definirem ara els nostres propis senyals. Aix\u00f2 ens ajudar\u00e0 a desacoblar (independitzar, fer que no depenguen unes de altres) les diferents part del programa. A m\u00e9s, ens permetr\u00e0 fer la nostra aplicaci\u00f3 responsiva , en compte de tindre un gran m\u00e8tode update , podem partir el treball entre m\u00faltiples ranures i llan\u00e7ar-les amb una sola senyal. Utilitzarem la classe Signal amb els tipus que ens interesse: import sys from PySide6.QtCore import Qt, Signal from PySide6.QtWidgets import QApplication, QMainWindow class MainWindow(QMainWindow): message = Signal(str) value = Signal(int, str, int) another = Signal(list) onemore = Signal(dict) anything = Signal(object) def __init__(self): super().__init__() self.message.connect(self.custom_slot) self.value.connect(self.custom_slot) self.another.connect(self.custom_slot) self.onemore.connect(self.custom_slot) self.anything.connect(self.custom_slot) self.message.emit(\"my message\") self.value.emit(23, \"abc\", 1) self.another.emit([1, 2, 3, 4, 5]) self.onemore.emit({\"a\": 2, \"b\": 7}) self.anything.emit(1223) def custom_slot(self, a): print(a) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Podeu baixar el codi ac\u00ed Com podeu observar, utilitzem el m\u00e8tode emit per a llan\u00e7ar el senyal, que \u00e9s capa\u00e7 de transmetre informaci\u00f3 de qualsevol tipus, per\u00f2 no \u00e9s una bona idea que les ranures reben qualsevol tipus, ja que s'hauria de gestionar a la funci\u00f3, cosa que la complicaria molt. Pots crear senyals en qualsevol subclasse de QObject , incl\u00f2s components, finestres i dialegs.","title":"Senyals definits per l'usuari"},{"location":"unitats/pyside6/pyside6-signals-slots/#modifiquem-la-informacio-emesa-pels-senyals","text":"Ja hem vist que els senyals poden emetre informaci\u00f3 a les ranures. Per\u00f2 els senyals predefinits, sols envien dades que s'ha definit que envien en el seu disseny. Per exemple, QPushButton.clicked sols envia el valor de checked despr\u00e9s de produir-se l'esdeveniment. Per a botons no seleccionable, setCheckable(False) , sempre enviar\u00e0 el valor False . Per solucionar este problema podem interceptar el senyal i modificar les dades: import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self): super().__init__() btn = QPushButton(\"Press me\") btn.setCheckable(True) btn.clicked.connect(lambda checked: self.button_clicked(checked, btn)) self.setCentralWidget(btn) def button_clicked(self, checked, btn): print(btn, checked) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed En aquest cas, el senyal clicked emetr\u00e0 l'estat de checked . La funci\u00f3 lambda intercepta el senyal i afegeix la informaci\u00f3 de l'objecte btn .","title":"Modifiquem la informaci\u00f3 emesa pels senyals"},{"location":"unitats/pyside6/pyside6-signals-slots/#activitat-5","text":"Fes una aplicaci\u00f3 que tinga un bot\u00f3. Al fer clic sobre ell, s'executar\u00e0 una funci\u00f3 que rebr\u00e0 l'estat del bot\u00f3. A m\u00e9s, emetr\u00e0 un nou senyal connectat a una altra funci\u00f3, que rebr\u00e0 l'estat del senyal i un n\u00famero aleatori. Al rebre la nova funci\u00f3 el senyal, imprimir\u00e0 per pantalla els valors del l'estat del bot\u00f3 i el n\u00famero aleatori.","title":"Activitat 5"},{"location":"unitats/pyside6/pyside6-signals-slots/#esdeveniments","text":"Cada interacci\u00f3 que l'usuari t\u00e9 amb una aplicaci\u00f3 Qt \u00e9s un esdeveniment. Hi ha molts tipus d'esdeveniments. Cada esdeveniment \u00e9s un objecte que empaqueta informaci\u00f3 sobre la interacci\u00f3 que l'ha produ\u00eft. Els esdeveniments es passen a controladors d'esdeveniments ( event handler ) espec\u00edfics del component on s'ha produ\u00eft la interacci\u00f3. Podem definir gestors d'esdeveniments personalitzats, modificant la manera com els vostres components responen a aquests esdeveniments. Els controladors d'esdeveniments es defineixen com qualsevol altre m\u00e8tode, per\u00f2 el nom \u00e9s espec\u00edfic per al tipus d'esdeveniment que gestionen. Un dels principals esdeveniments que reben els components \u00e9s el QMouseEvent. Els esdeveniments QMouseEvent es produixen en moure i clicar el ratol\u00ed sobre un component. Els seg\u00fcents gestors d'esdeveniments estan disponibles per gestionar els esdeveniments del ratol\u00ed: Gestor d'esdeveniment Tipus d'esdeveniment mouseMoveEvent Moviment de ratol\u00ed mousePressEvent Bot\u00f3 del ratol\u00ed premut mouseReleaseEvent Bot\u00f3 de ratol\u00ed soltat mouseDoubleClickEvent Doble clic detectat Per exemple, fer clic en un component provocar\u00e0 que s'envie un QMouseEvent al gestor d'esdeveniments .mousePressEvent del component. Aquest controlador pot utilitzar l'objecte d'esdeveniment per recollir informaci\u00f3 sobre qu\u00e8 ha passat, com ara qu\u00e8 va desencadenar l'esdeveniment i on concretament es va produir. Podeu interceptar esdeveniments heretant i anul\u00b7lant el m\u00e8tode del controlador a la classe derivada. Podeu triar filtrar, modificar o ignorar esdeveniments, passant-los al controlador normal de l'esdeveniment cridant a la funci\u00f3 de classe pare amb m\u00e8tode super(). Veiem a\u00e7\u00f2 amb una finestra principal. En cada cas, e rebr\u00e0 l'esdeveniment produ\u00eft. import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QTextEdit class MainWindow(QMainWindow): def __init__(self): super().__init__() self.label = QLabel(\"Click in this window\") self.setCentralWidget(self.label) def mouseMoveEvent(self, e): self.label.setText(\"mouseMoveEvent\") def mousePressEvent(self, e): self.label.setText(\"mousePressEvent\") def mouseReleaseEvent(self, e): self.label.setText(\"mouseReleaseEvent\") def mouseDoubleClickEvent(self, e): self.label.setText(\"mouseDoubleClickEvent\") app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Observeu que els esdeveniments de moviment del ratol\u00ed nom\u00e9s es registren quan teniu el bot\u00f3 premut. Podeu canviar-ho afegint un atribut al widget central i cridant ade la finestra. self.centralWidget().setAttribute(Qt.WA_TransparentForMouseEvents) self.setMouseTracking(False) Tamb\u00e9 podeu notar que els esdeveniments de clic i de doble clic es desencadenen quan es prem el bot\u00f3. Nom\u00e9s l'esdeveniment de soltar es dispara quan es deixa de pr\u00e9mer.","title":"Esdeveniments"},{"location":"unitats/pyside6/pyside6-widgets/","text":"Components (Widgets) A Qt (i la majoria de les interf\u00edcies d'usuari) widget \u00e9s el nom donat a un component de la interf\u00edcie d'usuari amb el qual l'usuari pot interactuar. Les interf\u00edcies d'usuari estan formades per diversos widgets o components, disposats dins de la finestra. Qt inclou una gran selecci\u00f3 de widgets disponibles, i fins i tot us permet crear els vostres propis components personalitzats. Una demostraci\u00f3 r\u00e0pida Primer fem una ullada a alguns dels widgets PySide m\u00e9s comuns. El codi seg\u00fcent crea una s\u00e8rie de ginys PySide i els afegeix a un disseny de finestra perqu\u00e8 pugueu veure'ls junts. Veurem com funcionen els *layouts* a m\u00e9s endavant. import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDial, QDoubleSpinBox, QFontComboBox, QLabel, QLCDNumber, QLineEdit, QMainWindow, QProgressBar, QPushButton, QRadioButton, QSlider, QSpinBox, QTimeEdit, QVBoxLayout, QWidget, ) # Subclass QMainWindow to customize your application's main window class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"Widgets App\") layout = QVBoxLayout() widgets = [ QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDial, QDoubleSpinBox, QFontComboBox, QLCDNumber, QLabel, QLineEdit, QProgressBar, QPushButton, QRadioButton, QSlider, QSpinBox, QTimeEdit, ] for w in widgets: layout.addWidget(w()) widget = QWidget() widget.setLayout(layout) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Podeu baixar el codi ac\u00ed Principals Widgets PySide6 t\u00e9 disponible multitud de widgets i cadascun d'ells s'utilitza de forma semblant, amb algunes peculiaritats segons el seu tipus. Veurem ara alguns exemples de cadascun dels principals Widgets: Label from PySide6.QtCore import Qt from PySide6.QtGui import QFont, QPixmap from PySide6.QtWidgets import QApplication, QLabel, QMainWindow class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QLabel(\"Hello\") widget.setPixmap(QPixmap(\"github/di21-22/docs/resources/code/PySide6/logo_qt.png\")) widget.setScaledContents(True) # font = widget.font() # font.setPointSize(30) # font.setFamily(\"Noto Serif Armenian\") # font.setBold(True) # widget.setFont(font) # widget.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter) self.setCentralWidget(widget) app = QApplication([]) main_window = MainWindow() main_window.show() app.exec() Pots baixar el codi ac\u00ed CheckBox from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QCheckBox class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") self.widget = QCheckBox() self.widget.setCheckState(Qt.Checked) self.widget.setTristate(True) # For tristate: self.widget.setCheckState(Qt.PartiallyChecked) # Or: self.widget.setTriState(True) self.widget.stateChanged.connect(self.show_state) self.setCentralWidget(self.widget) def show_state(self, s): print(s == Qt.Checked) print(s) self.widget.move(0, 50) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed ComboBox from PySide6.QtCore import Qt, QSize from PySide6.QtWidgets import QApplication, QMainWindow, QComboBox, QWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") self.widget = QWidget() self.combo_box = QComboBox(self.widget) self.combo_box.setFixedWidth(200) self.combo_box.addItems([\"One\", \"Two\", \"Three\"]) # The default signal from currentIndexChanged sends the index self.combo_box.currentIndexChanged.connect(self.index_changed) # The same signal can send a text string self.combo_box.currentTextChanged.connect(self.text_changed) self.setCentralWidget(self.widget) def index_changed(self, i): # i is an int print(i) def text_changed(self, s): # s is a str print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed ListWidget from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QListWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QListWidget() widget.addItems([\"One\", \"Two\", \"Three\"]) # In QListWidget there are two separate signals for the item, and the str widget.currentItemChanged.connect( self.index_changed ) widget.currentTextChanged.connect( self.text_changed ) self.setCentralWidget(widget) def index_changed(self, i): # Not an index, i is a QListItem print(i.text()) def text_changed(self, s): # s is a str print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed LineEdit from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QLineEdit, QWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QWidget() line_edit = QLineEdit(widget) line_edit.setMaxLength(10) line_edit.setPlaceholderText(\"Enter your text\") #widget.setReadOnly(True) # uncomment this to make readonly line_edit.returnPressed.connect(self.return_pressed) line_edit.selectionChanged.connect(self.selection_changed) line_edit.textChanged.connect(self.text_changed) line_edit.textEdited.connect(self.text_edited) self.setCentralWidget(widget) def return_pressed(self): print(\"Return pressed!\") self.centralWidget().setText(\"BOOM!\") def selection_changed(self): print(\"Selection changed\") print(self.centralWidget().selectedText()) def text_changed(self, s): print(\"Text changed...\") print(s) def text_edited(self, s): print(\"Text edited...\") print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed SpinBox from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QSpinBox class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QSpinBox() # Or: widget = QDoubleSpinBox() widget.setMinimum(-10) widget.setMaximum(3) # Or: widget.setRange(-10,3) widget.setPrefix(\"$\") widget.setSuffix(\"c\") widget.setSingleStep(3) # Or e.g. 0.5 for QDoubleSpinBox widget.valueChanged.connect(self.value_changed) widget.textChanged.connect(self.value_changed_str) self.setCentralWidget(widget) def value_changed(self, i): print(i) def value_changed_str(self, s): print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Slider from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QSlider, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QWidget() slider = QSlider(widget) self.label = QLabel(\" 0 \",widget) self.label.move(25,0) slider.setMinimum(-10) slider.setMaximum(3) # Or: widget.setRange(-10,3) slider.setSingleStep(1) slider.setSliderPosition(0) slider.valueChanged.connect(self.value_changed) slider.sliderMoved.connect(self.slider_position) slider.sliderPressed.connect(self.slider_pressed) slider.sliderReleased.connect(self.slider_released) self.setCentralWidget(widget) def value_changed(self, i): self.label.setText(str(i)) def slider_position(self, p): print(\"position\", p) def slider_pressed(self): print(\"Pressed!\") def slider_released(self): print(\"Released\") app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Dial from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QDial, QVBoxLayout, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QWidget() layout = QVBoxLayout(widget) dial = QDial() dial.setRange(0,60) dial.setSingleStep(1) layout.addWidget(dial) self.label = QLabel(f'Value: {dial.sliderPosition()}') layout.addWidget(self.label) dial.valueChanged.connect(self.value_changed) dial.sliderMoved.connect(self.slider_position) dial.sliderPressed.connect(self.slider_pressed) dial.sliderReleased.connect(self.slider_released) self.setCentralWidget(widget) def value_changed(self, i): text = f'Value: {i}' self.label.setText(text) def slider_position(self, p): print(\"position\", p) def slider_pressed(self): print(\"Pressed!\") def slider_released(self): print(\"Released\") app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed Activitat 6 Fes una aplicaci\u00f3 amb un dial, un slider i un label. Tant l'slider com el dial tindran valors entre 0 i 10. Quan es moga l'slider, el dial es mour\u00e0 agafant el mateix valor i el label mostrar\u00e0 el seu valor. Quan es mou el dial, el comportament ser\u00e0 el mateix.","title":"Widgets"},{"location":"unitats/pyside6/pyside6-widgets/#components-widgets","text":"A Qt (i la majoria de les interf\u00edcies d'usuari) widget \u00e9s el nom donat a un component de la interf\u00edcie d'usuari amb el qual l'usuari pot interactuar. Les interf\u00edcies d'usuari estan formades per diversos widgets o components, disposats dins de la finestra. Qt inclou una gran selecci\u00f3 de widgets disponibles, i fins i tot us permet crear els vostres propis components personalitzats.","title":"Components (Widgets)"},{"location":"unitats/pyside6/pyside6-widgets/#una-demostracio-rapida","text":"Primer fem una ullada a alguns dels widgets PySide m\u00e9s comuns. El codi seg\u00fcent crea una s\u00e8rie de ginys PySide i els afegeix a un disseny de finestra perqu\u00e8 pugueu veure'ls junts. Veurem com funcionen els *layouts* a m\u00e9s endavant. import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import ( QApplication, QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDial, QDoubleSpinBox, QFontComboBox, QLabel, QLCDNumber, QLineEdit, QMainWindow, QProgressBar, QPushButton, QRadioButton, QSlider, QSpinBox, QTimeEdit, QVBoxLayout, QWidget, ) # Subclass QMainWindow to customize your application's main window class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"Widgets App\") layout = QVBoxLayout() widgets = [ QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDial, QDoubleSpinBox, QFontComboBox, QLCDNumber, QLabel, QLineEdit, QProgressBar, QPushButton, QRadioButton, QSlider, QSpinBox, QTimeEdit, ] for w in widgets: layout.addWidget(w()) widget = QWidget() widget.setLayout(layout) # Set the central widget of the Window. Widget will expand # to take up all the space in the window by default. self.setCentralWidget(widget) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Podeu baixar el codi ac\u00ed","title":"Una demostraci\u00f3 r\u00e0pida"},{"location":"unitats/pyside6/pyside6-widgets/#principals-widgets","text":"PySide6 t\u00e9 disponible multitud de widgets i cadascun d'ells s'utilitza de forma semblant, amb algunes peculiaritats segons el seu tipus. Veurem ara alguns exemples de cadascun dels principals Widgets:","title":"Principals Widgets"},{"location":"unitats/pyside6/pyside6-widgets/#label","text":"from PySide6.QtCore import Qt from PySide6.QtGui import QFont, QPixmap from PySide6.QtWidgets import QApplication, QLabel, QMainWindow class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QLabel(\"Hello\") widget.setPixmap(QPixmap(\"github/di21-22/docs/resources/code/PySide6/logo_qt.png\")) widget.setScaledContents(True) # font = widget.font() # font.setPointSize(30) # font.setFamily(\"Noto Serif Armenian\") # font.setBold(True) # widget.setFont(font) # widget.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter) self.setCentralWidget(widget) app = QApplication([]) main_window = MainWindow() main_window.show() app.exec() Pots baixar el codi ac\u00ed","title":"Label"},{"location":"unitats/pyside6/pyside6-widgets/#checkbox","text":"from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QCheckBox class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") self.widget = QCheckBox() self.widget.setCheckState(Qt.Checked) self.widget.setTristate(True) # For tristate: self.widget.setCheckState(Qt.PartiallyChecked) # Or: self.widget.setTriState(True) self.widget.stateChanged.connect(self.show_state) self.setCentralWidget(self.widget) def show_state(self, s): print(s == Qt.Checked) print(s) self.widget.move(0, 50) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"CheckBox"},{"location":"unitats/pyside6/pyside6-widgets/#combobox","text":"from PySide6.QtCore import Qt, QSize from PySide6.QtWidgets import QApplication, QMainWindow, QComboBox, QWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") self.widget = QWidget() self.combo_box = QComboBox(self.widget) self.combo_box.setFixedWidth(200) self.combo_box.addItems([\"One\", \"Two\", \"Three\"]) # The default signal from currentIndexChanged sends the index self.combo_box.currentIndexChanged.connect(self.index_changed) # The same signal can send a text string self.combo_box.currentTextChanged.connect(self.text_changed) self.setCentralWidget(self.widget) def index_changed(self, i): # i is an int print(i) def text_changed(self, s): # s is a str print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"ComboBox"},{"location":"unitats/pyside6/pyside6-widgets/#listwidget","text":"from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QListWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QListWidget() widget.addItems([\"One\", \"Two\", \"Three\"]) # In QListWidget there are two separate signals for the item, and the str widget.currentItemChanged.connect( self.index_changed ) widget.currentTextChanged.connect( self.text_changed ) self.setCentralWidget(widget) def index_changed(self, i): # Not an index, i is a QListItem print(i.text()) def text_changed(self, s): # s is a str print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"ListWidget"},{"location":"unitats/pyside6/pyside6-widgets/#lineedit","text":"from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QLineEdit, QWidget class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.setWindowTitle(\"My App\") widget = QWidget() line_edit = QLineEdit(widget) line_edit.setMaxLength(10) line_edit.setPlaceholderText(\"Enter your text\") #widget.setReadOnly(True) # uncomment this to make readonly line_edit.returnPressed.connect(self.return_pressed) line_edit.selectionChanged.connect(self.selection_changed) line_edit.textChanged.connect(self.text_changed) line_edit.textEdited.connect(self.text_edited) self.setCentralWidget(widget) def return_pressed(self): print(\"Return pressed!\") self.centralWidget().setText(\"BOOM!\") def selection_changed(self): print(\"Selection changed\") print(self.centralWidget().selectedText()) def text_changed(self, s): print(\"Text changed...\") print(s) def text_edited(self, s): print(\"Text edited...\") print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"LineEdit"},{"location":"unitats/pyside6/pyside6-widgets/#spinbox","text":"from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QMainWindow, QSpinBox class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QSpinBox() # Or: widget = QDoubleSpinBox() widget.setMinimum(-10) widget.setMaximum(3) # Or: widget.setRange(-10,3) widget.setPrefix(\"$\") widget.setSuffix(\"c\") widget.setSingleStep(3) # Or e.g. 0.5 for QDoubleSpinBox widget.valueChanged.connect(self.value_changed) widget.textChanged.connect(self.value_changed_str) self.setCentralWidget(widget) def value_changed(self, i): print(i) def value_changed_str(self, s): print(s) app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"SpinBox"},{"location":"unitats/pyside6/pyside6-widgets/#slider","text":"from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QSlider, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QWidget() slider = QSlider(widget) self.label = QLabel(\" 0 \",widget) self.label.move(25,0) slider.setMinimum(-10) slider.setMaximum(3) # Or: widget.setRange(-10,3) slider.setSingleStep(1) slider.setSliderPosition(0) slider.valueChanged.connect(self.value_changed) slider.sliderMoved.connect(self.slider_position) slider.sliderPressed.connect(self.slider_pressed) slider.sliderReleased.connect(self.slider_released) self.setCentralWidget(widget) def value_changed(self, i): self.label.setText(str(i)) def slider_position(self, p): print(\"position\", p) def slider_pressed(self): print(\"Pressed!\") def slider_released(self): print(\"Released\") app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"Slider"},{"location":"unitats/pyside6/pyside6-widgets/#dial","text":"from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QDial, QVBoxLayout, QWidget class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"My App\") widget = QWidget() layout = QVBoxLayout(widget) dial = QDial() dial.setRange(0,60) dial.setSingleStep(1) layout.addWidget(dial) self.label = QLabel(f'Value: {dial.sliderPosition()}') layout.addWidget(self.label) dial.valueChanged.connect(self.value_changed) dial.sliderMoved.connect(self.slider_position) dial.sliderPressed.connect(self.slider_pressed) dial.sliderReleased.connect(self.slider_released) self.setCentralWidget(widget) def value_changed(self, i): text = f'Value: {i}' self.label.setText(text) def slider_position(self, p): print(\"position\", p) def slider_pressed(self): print(\"Pressed!\") def slider_released(self): print(\"Released\") app = QApplication([]) window = MainWindow() window.show() app.exec() Pots baixar el codi ac\u00ed","title":"Dial"},{"location":"unitats/pyside6/pyside6-widgets/#activitat-6","text":"Fes una aplicaci\u00f3 amb un dial, un slider i un label. Tant l'slider com el dial tindran valors entre 0 i 10. Quan es moga l'slider, el dial es mour\u00e0 agafant el mateix valor i el label mostrar\u00e0 el seu valor. Quan es mou el dial, el comportament ser\u00e0 el mateix.","title":"Activitat 6"}]}